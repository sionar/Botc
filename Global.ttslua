--[[
Blood in the Clocktower Scripted
Made by Sionar
UI code borrowed from Lost Savage and SilentxDream
--]]


------------------Constants
MOD_NAME = 'Blood on the Clocktower'
VERSION = '20.5.0'
LANGUAGE = 'ENG'
DEBUG = false
START_MESSAGE = 'Blood on the Clocktower\n Version [00FF00]'  .. VERSION .. '[-]\n\n' ..
[[
[89C381]Player chat commands:[-]
[967BB6]c[-] : See the list of chat commands.
[967BB6]h[-] : Show the vote history.
[967BB6]r[-] : Show your character.
[967BB6]l[-] : Show all the logs.
[967BB6]n[-] : Show the night logs.
[967BB6]d[-] : Show the day logs.
[967BB6]w[-] [E29A8A]color[-] [49D5FD]message[-] : Whisper a player.
[967BB6].color[-] [49D5FD]message[-] : Whisper a player.

[89C381]Storyteller chat commands:[-]
[967BB6].m[-] [B8F161]player[-] [E29A8A]color[-] : Move a player to a color.
[967BB6].u[-] [B8F161]player[-] [FF007F]team[-] : Move a player to a team.
[967BB6].b[-] [E29A8A]color[-] : Move a color to Grey.
[967BB6].s[-] [E29A8A]color[-] [E29A8A]color[-]: Swap two colors + chars.
[967BB6].t[-] [E29A8A]color[-]: Make color traveler/non-traveler.'
]]

HELP_MESSAGE =
[[
[89C381]Player chat commands:[-]
[967BB6]c[-] : See the list of chat commands.
[967BB6]h[-] : Show the vote history.
[967BB6]r[-] : Show your character.
[967BB6]v[-] : Show the version number.
[967BB6]l[-] : Show all the logs.
[967BB6]n[-] : Show the night logs.
[967BB6]d[-] : Show the day logs.
[967BB6]w[-] [E29A8A]color[-] [49D5FD]message[-] : Whisper a player.[-]
[967BB6].color[-] [49D5FD]message[-] : Whisper a player.[-]
]]

STORYTELLER_MESSAGE =
[[
[89C381]Storyteller chat commands:[-]
[967BB6]n[-] : Show the night logs.
[967BB6]d[-] : Show the day logs.
[967BB6].m[-] [B8F161]player[-] [E29A8A]color[-] : Move a player to a color.
[967BB6].u[-] [B8F161]player[-] [FF007F]team[-] : Move a player to a team.
[967BB6].b[-] [E29A8A]color[-] : Move a color to Grey.
[967BB6].s[-] [E29A8A]color[-] [E29A8A]color[-]: Swap two colors + chars.
[967BB6].t[-] [E29A8A]color[-]: Make color traveler/non-traveler.
]]

TABLE_OFFSET = 0
STORYTELLER_TABLE_DIST = 129
COLORS = {'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink'}
COLORS_EX = {'Magenta', 'Lavender', 'Navy', 'Cyan', 'Mint', 'Lime', 'Peach', 'Coral', 'Maroon', 'Silver'}
COLORS_ALL = {'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink', 'Magenta', 'Lavender', 'Navy', 'Cyan', 'Mint', 'Lime', 'Peach', 'Coral', 'Maroon', 'Silver'}
COLORS_TYPE = {White = true, Brown = true, Red = true, Orange = true, Yellow = true, Green = true, Teal = true, Blue = true, Purple = true, Pink = true, Magenta = false, Lavender = false, Navy = false, Cyan = false, Mint = false, Lime = false, Peach = false, Coral = false, Maroon = false, Silver = false}
COLORS_BBC = {White = '[FFFFFF]', Brown = '[703A16]', Red = '[DA1917]', Orange = '[F3631C]', Yellow = '[E6E42B]', Green = '[30B22A]', Teal = '[20B09A]', Blue = '[1E87FF]', Purple = '[9F1FEF]', Pink = '[F46FCD]', Magenta = '[FF007F]', Lavender = '[967BB6]', Navy = '[616BD4]', Cyan = '[49D5FD]', Mint = '[89C381]', Lime = '[B8F161]', Peach = '[F1D4A2]', Coral = '[E29A8A]', Maroon = '[800000]', Silver = '[BEBEBE]', Black = '[3F3F3F]', Grey = '[AAAAAA]'}
COLORS_BBC_ROLE_TYPE = {Townsfolk = '[1E87FF]', Outsider = '[20B09A]', Minion = '[F3631C]', Demon = '[DA1917]', Traveler = '[30B22A]'}
COLORS_RGB = {White = {1,1,1}, Brown = {113/255,59/255,23/255}, Red = {219/255,26/255,24/255}, Orange = {244/255,100/255,29/255}, Yellow = {231/255,229/255,44/255}, Green = {49/255,179/255,43/255}, Teal = {33/255,177/255,155/255}, Blue = {31/255,136/255,255/255}, Purple = {160/255,32/255,240/255}, Pink = {245/255,112/255,206/255}, Magenta = {255/255,0/255,127/255}, Lavender = {150/255,123/255,182/255}, Navy = {99/255,109/255,212/255}, Cyan = {73/255,213/255,253/255}, Mint = {137/255,195/255,129/255}, Lime = {184/255,241/255,97/255}, Peach = {241/255,212/255,162/255}, Coral = {226/255,154/255,138/255}, Maroon = {128/255,0,0}, Silver = {190/255,190/255,190/255},}
FAKE_ZONE_RGB = {Magenta = {255/255,0/255,127/255,0.16}, Lavender = {150/255,123/255,182/255,0.16}, Navy = {0/255,0/255,128/255,0.16}, Cyan = {73/255,213/255,253/255,0.16}, Mint = {137/255,195/255,129/255,0.16}, Lime = {184/255,241/255,97/255,0.16}, Peach = {241/255,212/255,162/255,0.16}, Coral = {226/255,154/255,138/255,0.16}, Maroon = {128/255,0,0,0.16}, Silver = {190/255,190/255,190/255,0.16},}
COLORS_UI = {Magenta = "#FF007F40|#FF007FFF|#FF007F80|#FF007F80", Lavender = "#967BB640|#967BB6FF|#967BB680|#967BB680", Navy = "#00008040|#000080FF|#00008080|#00008080", Cyan = "#49D5FD40|#49D5FDFF|#49D5FD80|#49D5FD80", Mint = "#89C38140|#89C381FF|#89C38180|#89C38180", Lime = "#B8F16140|#B8F161FF|#B8F16180|#B8F16180", Peach = "#F1D4A240|#F1D4A2FF|#F1D4A280|#F1D4A280", Coral = "#E29A8A40|#E29A8AFF|#E29A8A80|#E29A8A80", Maroon = "#80000040|#800000FF|#80000080|#80000080", Silver = "#BEBEBE40|#BEBEBEFF|#BEBEBE80|#BEBEBE80"}
COLORS_ORDER = {White = 1, Brown = 2, Red = 3, Orange = 4, Yellow = 5, Green = 6, Teal = 7, Blue = 8, Purple = 9, Pink = 10, Magenta = 11, Lavender = 12, Navy = 13, Cyan = 14, Mint = 15, Lime = 16, Peach = 17, Coral = 18, Maroon = 19, Silver = 20}
VOTEHAND_SHOW_SCALE = {3,1,3}
VOTEHAND_HIDE_SCALE = {0.01,0.01,0.01}
BG_POS = {188, 141, -395}

#include GUIDs.ttslua


------------------Variables
tableSize = 10
storytellerMode = false
firstLoad = true
options = {
    seatLock = false,
    tableText = true,
    decalsEnabled = true,
    jokersDefault = true,
    whispersOn = true,
    whisperLengthOn = true,
    safetyOn = true
}
timerID = 0
safetyExpired = true
started = false
lights = false
flipTimerExpired = true
autoTint = true
mode = 'TB'
notes = ''
history = {'[FFFFFF]Vote History:[-]'}
currentNominator = ''
currentNominated = ''
numAlive = 0
numPlayers = 0
numTrav = 0
currVotes = 0
currPlayers = 0
currMostVotes = 0
colors = {}
usedColors = {'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink', 'Magenta', 'Lavender', 'Navy', 'Cyan', 'Mint', 'Lime', 'Peach', 'Coral', 'Maroon', 'Silver'}
unusedColors = {}
for i = 1,10 do
    unusedColors[COLORS_ALL[i]] = false
end
for i = 11,20 do
    unusedColors[COLORS_ALL[i]] = true
end
removedColors = {}
chars = {}
angle = {}
lifeTokens = {}
lifeTokenPos = {}
canNominate = {}
canBeNominated = {}
living = {}
hasVote = {}
voted = {}
voteLock = {}
voteButtonsOn = {}
tokenTable = {}
decalTable = {}


for k,v in pairs(COLORS_ALL) do
    lifeTokens[v] = {object = nil, vote = nil}
    canNominate[v] = true
    canBeNominated[v] = true
    living[v] = true
    hasVote[v] = true
    voted[v] = false
    voteLock[v] = false
    voteButtonsOn[v] = false
end

players = {}
playersEx = {}
playersExIds = {}
avatarGuids = {}
for k,v in pairs(COLORS_EX) do
    playersEx[v] = nil
    playersExIds[v] = nil
    avatarGuids[v] = nil
end

avatarUrl = ''
uiWhisperColor = {}
for k,v in pairs(COLORS_ALL) do
    uiWhisperColor[v] = 'Black'
end
uiWhisperColor['Black'] = 'Black'

uiWhisperInput = {}
colorTable = false
uiVisibility = {}
for k,v in pairs(COLORS) do
    uiVisibility[v] = true
end
uiVisibility['Black'] = true

customSet = false
imageLoaded = false
customList = {}

whisperActive = {}
for k,v in pairs(COLORS_ALL) do
    whisperActive[v] = {}
    for k1,v1 in pairs(COLORS_ALL) do
        whisperActive[v][v1] = false
    end
end


------------------Functions
function onLoad(saveString)
    if saveString ~= nil then
        local save = JSON.decode(saveString)
        options = save['o']
        started = save['s']
        mode = save['m']
        chars = save['r']
        history = save['h']
        playersExIds = save['p']
        avatarGuids = save['a']
        customSet = save['c']
        imageLoaded = save['i']
        customList = save['cl']
        tableSize = save['t']
        colors = save['co']
        usedColors = save['ac']
        unusedColors = save['uc']
        removedColors = save['rc']
        angle = save['an']
        lights = save['l']
        autoTint = save['at']
        lifeTokenPos = save['lt']
    end

    local obj
    local allObjects = getAllObjects()
    obj = getObjectFromGUID(TABLE_GUID)
    if obj ~= nil then
        obj.interactable = false
    end

    obj = getObjectFromGUID(STORYTELLER_TABLE_GUID)
    if obj ~= nil then
        obj.interactable = false
    end

    obj = getObjectFromGUID(ROOM_GUID)
    if obj ~= nil then
        obj.interactable = false
    end

    obj = getObjectFromGUID(STORAGE_BAG_GUID)
    if obj ~= nil then
        obj.interactable = false
    end

    for k,v in pairs(NIGHT_LIGHT_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            if DEBUG then
                obj.setScale({1,1,1})
            else
                obj.setScale({0.01,0.01,0.01})
            end
        end
    end

    obj = getObjectFromGUID(VOTE_PANEL_GUID)
    if obj ~= nil then
        obj.interactable = false
    end

    for k,v in pairs(LIFE_BASE_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.setLock(true)
            obj.interactable = false
        end
    end


    for k,v in pairs(LIFE_TOKEN_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.setLock(true)
        end
    end

    for k,v in pairs(VOTEHAND_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.setLock(true)
            obj.interactable = false
        end
    end

    for k,v in pairs(allObjects) do
        if v.getName() == 'Background' or v.getName() == 'Skybox' then
            v.interactable = false
        end
    end

    if not started then
        notes = START_MESSAGE
        setNotes(notes)
        updateNotebookTabs()
    end

    createFlipButtons()

    Turns.order = {'Black', 'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink'}
    updateFakeZoneColliders()
    updateTokenStatus()
    refreshUI()
    showExtensionUI()
    Wait.time(refreshObjects,5)
    Wait.time(refreshBackground,3)
    Wait.time(refreshNotes,1,-1)
    Wait.time(updateTokenStatus,2,-1)
end

function onSave()
    local save = {}
    save['o'] = options
    save['s'] = started
    save['m'] = mode
    save['r'] = chars
    save['h'] = history
    save['p'] = playersExIds
    save['a'] = avatarGuids
    save['c'] = customSet
    save['i'] = imageLoaded
    save['cl'] = customList
    save['t'] = tableSize
    save['co'] = colors
    save['ac'] = usedColors
    save['uc'] = unusedColors
    save['rc'] = removedColors
    save['an'] = angle
    save['l'] = lights
    save['at'] = autoTint
    save['lt'] = lifeTokenPos
    local saveString = JSON.encode(save)
    return saveString
end

function updateNotebookTabs()
    editNotebookTab(2, TB_LIST, 'Trouble Brewing Characters')
    editNotebookTab(3, BM_LIST, 'Bad Moon Rising Characters')
    editNotebookTab(4, SV_LIST, 'Sects & Violets Characters')
end

function editNotebookTab(tabIndex, charList, title)
    local tab = {index = tabIndex, title = title, color = 'Grey'}
    local text = ''

    for k,v in pairs(TYPES) do
        text = text .. '[i]' .. v .. '[/i]\r\n'
        for k1,v1 in pairs(charList) do
            if CHARACTERS[v1].Type == v then
                text = text .. '\r\n[b]' .. v1 .. '[/b] - ' .. CHARACTERS[v1].Description
            end
        end
        text = text .. '\r\n\n\r\n'
    end

    tab.body = text
    Notes.editNotebookTab(tab)
end

function refreshObjects()
    local obj, clock
    obj = getObjectFromGUID(TEAM_TOOL_GUID)
    if obj ~= nil then
        obj.reload()
    end

    for k,v in pairs(VOTEHAND_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.reload()
        end
    end

    for k,v in pairs(LIFE_BASE_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.reload()
        end
    end

    for k,v in pairs(LIFE_TOKEN_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.reload()
        end
    end

    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls ~= nil then
        local clockOn = clockControls.getVar('clockOn')
        if clockOn then
            Wait.time(function () showVoteButtons({voteMode = 'execution'}) end, 2)
        end
    end
    Wait.time(lockObjects, 2)
end

function refreshBackground()
    local obj = getObjectFromGUID(BG_OBJ_GUID)
    if obj ~= nil then
        obj.setLock(false)
        Wait.frames(function() obj.setPosition(BG_POS) end, 2)
        Wait.frames(function() obj.setLock(true) end, 5)
    end
end

function lockObjects()
    local obj

    for k,v in pairs(VOTEHAND_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.interactable = false
        end
    end

    for k,v in pairs(LIFE_BASE_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            obj.interactable = false
        end
    end

    for k,v in pairs(LIFE_TOKEN_GUIDS) do
        obj = getObjectFromGUID(v)
        if obj ~= nil then
            if storytellerMode then
                obj.setLock(false)
            else
                obj.setLock(true)
            end
        end
    end

    createFlipButtons()
end

function resetNotes()
    notes = START_MESSAGE
    setNotes(notes)
end

function refreshNotes()
    setNotes(notes)
end

function updateTokenStatus()
    updatePlayers()
    getLifeTokens()
    handleLifeUI()
end

function updatePlayers()
    local allPlayers = Player.getPlayers()
    local found
    local textObj
    local mainTable = getObjectFromGUID(TABLE_GUID)
    local prevNumPlayers = numPlayers
    local currNumPlayers = 0

    for k,v in pairs(COLORS) do
        if Player[v].seated then
            players[v] = Player[v]
            currNumPlayers = currNumPlayers + 1
        else
            players[v] = nil
        end
    end
    if Player['Black'].seated then
        players['Black'] = Player['Black']
    else
        players['Black'] = nil
    end

    for k,v in pairs(COLORS_EX) do
        if playersExIds[v] == nil then    --no id for that color
            playersEx[v] = nil
        else
            found = nil
            for k1,v1 in pairs(allPlayers) do
                if v1.steam_id == playersExIds[v] and v1.color == 'Grey' then
                    found = v1
                    currNumPlayers = currNumPlayers + 1
                    break
                end
            end
            if found == nil then        --cannot find player with that id
                playersExIds[v] = nil
                playersEx[v] = nil
                mainTable.call('setName', {color = v, name = ''})
                deleteAvatar(v)
            else
                playersEx[v] = found
            end
        end
        players[v] = playersEx[v]
    end
    characterTool = getObjectFromGUID(CHARACTER_TOOL_GUID)
    if characterTool ~= nil and prevNumPlayers ~= currNumPlayers and not storytellerMode then
        characterTool.call('refreshMenu')
    end
    updateSitUI()
    return players
end

function getPlayer(player)
    for k,v in pairs(players) do
        if v ~= nil and v.steam_id == player.steam_id then
            return k
        end
    end
    return nil
end

function getLifeTokens()
    local base, pos
    local lifeTokenFound, voteTokenFound, objectsFound

    for k,v in pairs(COLORS_ALL) do
        base = getObjectFromGUID(LIFE_BASE_GUIDS[v])
        if base == nil then
            lifeTokens[v].vote = nil
            lifeTokens[v].object = nil
        else
            pos = base.getPosition()
            lifeTokenFound = false
            voteTokenFound = false
            objectsFound = Physics.cast({
                origin       = pos,
                direction    = {0, 1, 0},
                type         = 1, -- int (1: Ray, 2: Sphere, 3: Box),
                max_distance = 3,
                debug        = false-- bool (true = visualize cast),
            }) -- returns { {Vector point, Vector normal, float distance, Object hit_object}, {...}, ...}

            for i, hit in ipairs(objectsFound) do
                if hit.hit_object.getName() == 'Life Token' then
                    lifeTokens[v].object = hit.hit_object
                    lifeTokenFound = true
                elseif hit.hit_object.getName() == 'Vote Token' then
                    lifeTokens[v].vote = hit.hit_object
                    voteTokenFound = true
                end
            end
            if not voteTokenFound then
                lifeTokens[v].vote = nil
            end
            if not lifeTokenFound then
                lifeTokens[v].object = nil
            end
        end
    end
end

function handleLifeUI()
    numAlive = 0
    numPlayers = 0
    local numberOfSkipped = 0 -- number of players not seated
    local numberOfVotes = 0
    local votesNeeded = 0
    local playerDist
    local allObjects = getAllObjects()
    local allPlayers = Player.getPlayers()
    local currentNumTrav = 0
    local aliveTrav = 0
    local zoneObj

    for i=1,20 do
        zoneObj = getObjectFromGUID(ZONE_GUIDS[COLORS_ALL[i]])
        if lifeTokens[COLORS_ALL[i]].object ~= nil and (players[COLORS_ALL[i]] ~= nil or storytellerMode) then
            if started and i <= 10 and zoneObj ~= nil then
                zoneObj.setValue(COLORS_ALL[i])
            end
            if started and i > 10 and zoneObj ~= nil then
                zoneObj.setColorTint(FAKE_ZONE_RGB[COLORS_ALL[i]])
            end
            numPlayers = numPlayers + 1
            if lifeTokens[COLORS_ALL[i]].object.is_face_down == true then -- if life token is face down...
                if lifeTokens[COLORS_ALL[i]].vote ~= nil then -- ..then if a vote token is present
                    UI.setAttribute('aliveImage'..i - numberOfSkipped, 'image', 'deadWithVote'..i)  -- counting skipped players to only make last images transparent
                    numberOfVotes = numberOfVotes + 1
                else
                    UI.setAttribute('aliveImage'..i - numberOfSkipped, 'image', 'deadNoVote') -- counting skipped players to only make last images transparent
                end
            else
                UI.setAttribute('aliveImage'..i - numberOfSkipped, 'image', 'alive'..i) -- counting skipped players to only make last images transparent
                numAlive = numAlive +1
                numberOfVotes = numberOfVotes + 1
                if lifeTokens[COLORS_ALL[i]].object.getDescription() == 'Traveler' then
                    aliveTrav = aliveTrav + 1
                end
            end
            if lifeTokens[COLORS_ALL[i]].object.getDescription() == 'Traveler' then
                currentNumTrav = currentNumTrav + 1
            end
        else
            if started and i <= 10 and zoneObj ~= nil and #allPlayers > 1 then
                zoneObj.setValue('Black')
            end
            if started and i > 10 and zoneObj ~= nil and #allPlayers > 1 then
                zoneObj.setColorTint({0.3,0.3,0.3,0.25})
            end
            numberOfSkipped = numberOfSkipped +1
            UI.setAttribute('aliveImage'..21 - numberOfSkipped, 'image', 'empty') -- starting from 11 to work backwards through list of aliveImage
        end
    end
    votesNeeded = math.ceil(numAlive/2)
    if firstLoad or currPlayers ~= numAlive or currVotes ~= numberOfVotes or numTrav ~= currentNumTrav then
        firstLoad = false
        for k,v in pairs(allObjects) do
            if v.getName() == 'Player Distribution Chart' then
                v.call('updatePlayerDist', {num = numPlayers - currentNumTrav})
                v.call('updateAlive', {numP = numPlayers, living = numAlive, nonTrav = numAlive - aliveTrav, withVotes = numberOfVotes, needed = votesNeeded})
            end
        end
    end
    if storytellerMode then
        for k,v in pairs(allObjects) do
            if v.getName() == 'Player Distribution Chart' then
                v.call('updatePlayerDistST', {num = numPlayers - numTrav})
            end
        end
    end

    currPlayers = numAlive
    currVotes = numberOfVotes
    numTrav = currentNumTrav
end

function inTable(input, table)
    for k,v in pairs(table) do
        if input == v then
            return true
        end
    end
    return false
end

function findColor(input)
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(input)) then
            return v
        end
    end
    if string.match('black', string.lower(input)) then
        return 'Black'
    end
    return nil
end

------------------Table setup commands
function radius(rad, angle, height)
    return {rad*math.sin(angle*math.pi/180), height, rad*math.cos(angle*math.pi/180) + TABLE_OFFSET}
end

function resizeTable()
    local obj, objs, tab, pos, rot, colorPos
    local charSheetGuids
    local angleFirst, angleInc
    local zoneSize
    local storageBag = getObjectFromGUID(STORAGE_BAG_GUID)
    local voteTokenBag = getObjectFromGUID(VOTE_TOKEN_BAG_GUID)
    local votePanel = getObjectFromGUID(VOTE_PANEL_GUID)
    local radSt = tableSize * 0.6 + 6
    local fontSize
    local idx
    local numGreySeats = getNumGreySeats()

    if mode == 'TB' then
        charSheetGuids = CHAR_SHEET_GUIDS_TB
    elseif mode == 'BM' then
        charSheetGuids = CHAR_SHEET_GUIDS_BM
    elseif mode == 'SV' then
        charSheetGuids = CHAR_SHEET_GUIDS_SV
    elseif mode == 'CU' then
        charSheetGuids = CHAR_SHEET_GUIDS_CU
    end

    updatePlayers()
    colors = {}
    unusedColors = {}
    for i = 1, 20 do
        unusedColors[COLORS_ALL[i]] = true
    end
    angle = {}
    for i = 1, tableSize do
        table.insert(colors, usedColors[i])
        unusedColors[usedColors[i]] = false
        angle[usedColors[i]] = (180 + 360 / tableSize * (i-1)) % 360
    end
    zoneSize = 2 * 71.5 * math.sin(math.pi / tableSize) * 0.67
    if zoneSize > 40 then
        zoneSize = 40
    end

    if tableSize > 10 and tableSize < 15 then
        UI.setAttribute('sitTable', 'width', 100*(tableSize-10))
    else
        UI.setAttribute('sitTable', 'width', 500)
    end

    for k,color in pairs(colors) do
        obj = getObjectFromGUID(ZONE_GUIDS[color])
        if obj == nil then
            obj = storageBag.takeObject({guid = ZONE_GUIDS[color], rotation = {0, angle[color], 0}})
        end
        if obj ~= nil then
            obj.setLock(true)
            obj.setScale({zoneSize,10,13})
            obj.setPositionSmooth(radius(71.5,angle[color], 1))
            obj.setRotationSmooth({0, angle[color], 0})
        end
        obj = getObjectFromGUID(charSheetGuids[color])
        if obj ~= nil then
            obj.setLock(true)
            obj.setScale({1.64,1,1.64})
            obj.setPositionSmooth(radius(72.5,angle[color], 1))
            obj.setRotationSmooth({0, angle[color], 0})
            obj.interactable = true
        end
        obj = getObjectFromGUID(VOTEHAND_GUIDS[color])
        if obj == nil then
            obj = storageBag.takeObject({guid = VOTEHAND_GUIDS[color], rotation = {0, angle[color], 0}})
        end
        if obj ~= nil then
            obj.setLock(true)
            obj.setPositionSmooth(radius(75, angle[color], -5))
            obj.setRotationSmooth({0, angle[color], 0})
        end
        obj = getObjectFromGUID(LIFE_BASE_GUIDS[color])
        if obj == nil then
            obj = storageBag.takeObject({guid = LIFE_BASE_GUIDS[color], rotation = {0, angle[color], 0}})
        end
        if obj ~= nil then
            obj.setLock(true)
            if storytellerMode then
                obj.setPosition(radius(radSt, angle[color], 1))
                obj.setRotation({0, angle[color], 0})
            else
                obj.setPosition(radius(55, angle[color], 1))
                obj.setRotation({0, angle[color], 0})
            end
        end
        if storytellerMode then
            lifeTokenPos[color] = radius(radSt, angle[color], 1.35)
        else
            lifeTokenPos[color] = radius(55, angle[color], 1.35)
        end
        obj = lifeTokens[color].object
        if (not obj and not started) or (not obj and started and chars[color] ~= nil and CHARACTERS[chars[color]].Type ~= 'Traveler') then
            objs = storageBag.getObjects()
            for k,v in pairs(objs) do
                if v.guid == LIFE_TOKEN_GUIDS[color] then
                    obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color]})
                    lifeTokens[color].object = obj
                    break
                end
            end
        end
        if obj ~= nil then
            if storytellerMode then
                obj.setLock(false)
            else
                obj.setLock(true)
            end
            obj.setScale({1.82,1,1.82})
            if obj.is_face_down then
                obj.setRotation({0,0,180})
            else
                obj.setRotation({0,0,0})
            end
            obj.setPosition(lifeTokenPos[color])
        end
        if lifeTokens[color].vote ~= nil then
            if storytellerMode then
                lifeTokens[color].vote.setPositionSmooth(radius(radSt, angle[color], 1.43))
            else
                lifeTokens[color].vote.setPositionSmooth(radius(55, angle[color], 1.43))
            end
        end
        UI.setAttribute('select'..color,'active','true')
        if COLORS_TYPE[color] == true then
            Player[color].setHandTransform({position = radius(82,angle[color], 1), rotation = {0, angle[color] + 180, 0}, scale = {14,5,6.5}})
        end
        if COLORS_TYPE[color] == false then
            obj = getObjectFromGUID(AVATAR_LIGHT_GUIDS[color])
            if obj == nil then
                obj = storageBag.takeObject({guid = AVATAR_LIGHT_GUIDS[color]})
            end
            if obj ~= nil then
                obj.setPositionSmooth(radius(81, angle[color], 6))
            end

            if avatarGuids[color] then
                obj = getObjectFromGUID(avatarGuids[color])
                if obj ~= nil then
                    obj.setPositionSmooth(radius(84, angle[color], 6))
                    obj.setRotationSmooth({180, angle[color], 180})
                end
            end
        end
    end
    for k,color in pairs(COLORS_ALL) do
        if unusedColors[color] == true then
            voted[color] = false
            obj = getObjectFromGUID(ZONE_GUIDS[color])
            if obj ~= nil then
                storageBag.putObject(obj)
            end

            obj = getObjectFromGUID(charSheetGuids[color])
            if obj ~= nil then
                obj.setScale({0.01,0.01,0.01})
                obj.setPositionSmooth({0,-1,0 + TABLE_OFFSET})
            end

            obj = getObjectFromGUID(VOTEHAND_GUIDS[color])
            if obj ~= nil then
                obj.setScale(VOTEHAND_HIDE_SCALE)
                storageBag.putObject(obj)
            end

            obj = getObjectFromGUID(LIFE_BASE_GUIDS[color])
            if obj ~= nil then
                storageBag.putObject(obj)
            end

            obj = getObjectFromGUID(LIFE_TOKEN_GUIDS[color])
            if obj ~= nil then
                storageBag.putObject(obj)
            end

            if lifeTokens[color].vote ~= nil then
                voteTokenBag.putObject(lifeTokens[color].vote)
            end
            UI.setAttribute('cell'..color,'active','false')
            UI.setAttribute('select'..color,'active','false')
            if COLORS_TYPE[color] == true then
                Player[color].setHandTransform({position = {0,1000,0}, scale = {0,0,0}})
                if Player[color].seated then
                    Player[color].changeColor('Grey')
                end
            end
            if COLORS_TYPE[color] == false then
                if players[color] ~= nil then
                    idx = getSeatIdx(color)
                    unsitGreyColor(players[color], color)
                end
                obj = getObjectFromGUID(AVATAR_LIGHT_GUIDS[color])
                if obj ~= nil then
                    storageBag.putObject(obj)
                end
            end
        end
    end
    mainTable = getObjectFromGUID(TABLE_GUID)
    mainTable.call('moveText', {tableSize = tableSize})
    createSnapPoints()
    toggleLights({switching = false})
    UI.setAttribute('colorSelection','active',false)
    obj = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    local clockOn
    if obj ~= nil then
        obj.call('updateSettings')
        clockOn = obj.getVar('clockOn')
        if clockOn then
            votePanel.call('createButtons')
        end
    end
    Wait.time(updateFakeZoneColliders, 1)
    showExtensionUI()
    if storytellerMode then
        obj = getObjectFromGUID(PLAYER_DIST_GUID)
        if obj ~= nil then
            obj.setPositionSmooth({0,1.25,0 + TABLE_OFFSET})
            obj.setRotationSmooth({0,0,0})
            obj.setScale({2 + 0.2 *(tableSize-5), 1, 2 + 0.2 *(tableSize-5)})
        end
    end

    Wait.time(lockObjects, 2)
end

function createSnapPoints()
    local snapTable = {}
    local pos, rad, radTokens
    rad = tableSize * 0.4 + 6
    radTokens = tableSize * 0.6 + 6

    table.insert(snapTable, {position = {0,0,0 + TABLE_OFFSET}, rotation = {0,180,0}, rotation_snap = true})
    table.insert(snapTable, {position = {-12,0,0 + TABLE_OFFSET}, rotation = {0,180,0}, rotation_snap = true})
    table.insert(snapTable, {position = {12,0,0 + TABLE_OFFSET}, rotation = {0,180,0}, rotation_snap = true})
    table.insert(snapTable, {position = {26,0,111 + TABLE_OFFSET}, rotation = {0,0,0}, rotation_snap = true})
    table.insert(snapTable, {position = {-4,1.12, STORYTELLER_TABLE_DIST + TABLE_OFFSET}, rotation = {0,0,0}, rotation_snap = true})
    table.insert(snapTable, {position = {0,1.12, STORYTELLER_TABLE_DIST + TABLE_OFFSET}, rotation = {0,0,0}, rotation_snap = true})
    table.insert(snapTable, {position = {4,1.12, STORYTELLER_TABLE_DIST + TABLE_OFFSET}, rotation = {0,0,0}, rotation_snap = true})

    for k,color in pairs(colors) do
        if not storytellerMode then
            table.insert(snapTable, {position = radius(55, angle[color], 1.16), rotation = {0, angle[color], 0}, rotation_snap = true})
        else
            table.insert(snapTable, {position = radius(radTokens, angle[color], 1.16), rotation = {0, angle[color], 0}, rotation_snap = true})
        end
        pos = radius(rad, angle[color], 1.0)
        pos[3] = pos[3] + STORYTELLER_TABLE_DIST
        table.insert(snapTable, {position = pos, rotation = {0,0,0}, rotation_snap = false})
    end
    self.setSnapPoints(snapTable)
end

function updateFakeZoneColliders()
    local component, obj
    for k,v in pairs(COLORS_EX) do
        obj = getObjectFromGUID(ZONE_GUIDS[v])
        if obj ~= nil then
            component = obj.getComponent("BoxCollider")
            component.set("enabled", false)
        end
    end
end

function setTokenTable()
    local objs, scriptZone
    local posTable = {}
    local rad = tableSize * 0.4 + 6
    local margin = 1.5

    if started then
        for k,v in pairs(colors) do
            posTable[v] = radius(rad, angle[v], 1.0)
            posTable[v][3] = posTable[v][3] + STORYTELLER_TABLE_DIST
        end
        tokenTable = {}
        scriptZone = getObjectFromGUID(SCRIPTING_ZONE_GUID)
        if scriptZone ~= nil then
            objs = scriptZone.getObjects()
            for k,v in pairs(colors) do
                tokenTable[v] = {}
                for k1, v1 in pairs(objs) do
                    if math.abs(posTable[v][1] - v1.getPosition()[1]) < margin and math.abs(posTable[v][3] - v1.getPosition()[3]) < margin then
                        table.insert(tokenTable[v], v1)
                    end
                end
            end
        end
    end
end

function setDecalTable()
    local globalDecals = Global.getDecals()
    local decalTab

    if globalDecals == nil then
        return
    end

    decalTable = {}
    for k,v in pairs(colors) do
        decalTable[v] = nil
        for i = 1,#globalDecals do
            if math.abs(globalDecals[i].position[1] - radius(48, angle[v], 1.1)[1]) < 0.01 and math.abs(globalDecals[i].position[3] - radius(48, angle[v], 1.1)[3]) < 0.01 then
                decalTable[v] = i
            end
        end
    end
end

function moveTokens()
    local objs, pos
    local posTable = {}
    local rad = tableSize * 0.4 + 6

    if started then
        for k,v in pairs(colors) do
            posTable[v] = radius(rad, angle[v], 1.0)
            posTable[v][3] = posTable[v][3] + STORYTELLER_TABLE_DIST
            if tokenTable[v] ~= nil then
                for k1,v1 in pairs(tokenTable[v]) do
                    pos = v1.getPosition()
                    v1.setPosition({posTable[v][1], pos[2], posTable[v][3]})
                end
            end
        end
    end
end

function moveDecals()
    local globalDecals = Global.getDecals()

    if globalDecals == nil then
        return
    end

    for k,v in pairs(colors) do
        if decalTable[v] ~= nil then
            globalDecals[decalTable[v]].position = radius(48, angle[v], 1.1)
            globalDecals[decalTable[v]].rotation = {90, angle[v] - 180, 0}
        end
    end

    local deletingIndexes = {}

    for k,color in pairs(unusedColors) do
        if decalTable[color] ~= nil then
            if #deletingIndexes == 0 then
                table.insert(deletingIndexes, decalTable[color])
            else
                for j = 1, #deletingIndexes do
                    if decalTable[color] > deletingIndexes[j] then
                        table.insert(deletingIndexes, j, decalTable[color])
                        break
                    end
                end

            end
        end
    end

    for i = 1, #deletingIndexes do
        table.remove(globalDecals, deletingIndexes[i])
    end
    Global.setDecals({})
    Global.setDecals(globalDecals)
end

function shuffleTable(tab)
    local rand
    if tab == nil then
        return nil
    end

    for i = #tab, 1, -1 do
        rand = math.random(1,i)
        tab[i], tab[rand] = tab[rand], tab[i]
    end
    return tab
end

function shufflePlayers()
    if started then
        return
    end
    local colorTab = {}
    local playerTab = {}
    local allPlayers
    local numGreySeats = getNumGreySeats()
    for k,v in pairs(COLORS) do
        if players[v] ~= nil then
            table.insert(colorTab, v)
            table.insert(playerTab, players[v].steam_id)
            players[v].changeColor('Grey')
        end
    end
    for k,v in pairs(COLORS_EX) do
        if players[v] ~= nil then
            table.insert(colorTab, v)
            table.insert(playerTab, players[v].steam_id)
            unsitGreyColor(players[v], color)
        end
    end
    if playerTab == nil then
        return
    end
    playerTab = shuffleTable(playerTab)
    allPlayers = Player.getPlayers()

    for k,v in pairs(colorTab) do
        for k1,v1 in pairs(allPlayers) do
            if v1.steam_id == playerTab[k] then
                if inTable(v, COLORS) then
                    v1.changeColor(v)
                else
                    sitGreyColor(v1, v)
                end
                break
            end
        end
    end
end

function pruneSeats()
    local numPlayers = getNumPlayers()
    if numPlayers < 5 then
        return
    end
    local tableControls = getObjectFromGUID(TABLE_SIZER_GUID)
    local seatTool = getObjectFromGUID(SEAT_TOOL_GUID)
    local found = 0
    local i = 1
    local idx
    local switch = {}
    local lastIndex = 0
    local color
    usedColors = {}
    unusedColors = {}
    removedColors = {}
    for i = 1, 20 do
        unusedColors[COLORS_ALL[i]] = true
    end
    for k,v in pairs(colors) do
        if players[v] ~= nil then
            table.insert(usedColors, v)
            unusedColors[v] = false
            last = COLORS_ORDER[v]
        end
    end
    for i = 1,20 do
        color = COLORS_ALL[i]
        if COLORS_ORDER[color] <= last then
            if players[color] == nil then
                table.insert(removedColors, color)
            end
        else
            table.insert(usedColors, color)
        end
    end
    setTokenTable()
    setDecalTable()
    tableSize = numPlayers
    resizeTable()
    moveTokens()
    moveDecals()

    if tableControls ~= nil then
        tableControls.setVar('tableSize', tableSize)
        tableControls.call('refreshUI')
        tableControls.setVar('maxSeats', #usedColors)
    end
    if seatTool ~= nil then
        seatTool.setTable('usedColors', usedColors)
        seatTool.setTable('removedColors', removedColors)
        seatTool.call('render')
    end
end

function toggleLights(params)
    local switching = params.switching
    local obj
    local backgroundBox = getObjectFromGUID(BACKGROUND_BOX_GUID)
    local clockLight = getObjectFromGUID(CLOCK_LIGHT_GUID)
    if switching then
        lights = not lights
    end
    if not lights then
        Lighting.ambient_type = 1
        Lighting.ambient_intensity = 2.3
        Lighting.light_intensity = 0.5
        Lighting.apply()
        local backgroundDeleted = getObjectFromGUID(TABLE_SIZER_GUID).getVar('backgroundDeleted')
        if backgroundBox and not backgroundDeleted then
            backgroundBox.setScale({1,1,1})
        end
        for k,v in pairs(NIGHT_LIGHT_GUIDS) do
            obj = getObjectFromGUID(v)
            if obj ~= nil then
                obj.setPosition({0,-0.1,0 + TABLE_OFFSET})
                obj.call('powerOff')
            end
        end
        if clockLight ~= nil then
            clockLight.call('powerOff')
        end
    else
        Lighting.ambient_type = 1
        Lighting.ambient_intensity = 0.0
        Lighting.light_intensity = 0.12
        Lighting.apply()
        if backgroundBox then
            backgroundBox.setScale({0.7,0.7,0.7})
        end
        obj = getObjectFromGUID(NIGHT_LIGHT_GUIDS.Table)
        if obj ~= nil then
            obj.setPosition({0,40,0 + TABLE_OFFSET})
            obj.call('powerOn')
        end
        obj = getObjectFromGUID(NIGHT_LIGHT_GUIDS.Black)
        if obj ~= nil then
            obj.setPosition({0,10,STORYTELLER_TABLE_DIST + TABLE_OFFSET})
            obj.call('powerOn')
        end
        if clockLight then
            clockLight.call('powerOn')
        end
        for k,color in pairs(colors) do
            obj = getObjectFromGUID(NIGHT_LIGHT_GUIDS[color])
            if obj ~= nil then
                obj.setPosition(radius(73.5,angle[color], 5))
                if customSet then
                    obj.call('powerOff')
                else
                    obj.call('powerOn')
                end
            end
        end
        for color,unused in pairs(unusedColors) do
            if unused == true then
                obj = getObjectFromGUID(NIGHT_LIGHT_GUIDS[color])
                if obj ~= nil then
                    obj.setPosition({0,-0.1,0 + TABLE_OFFSET})
                    obj.call('powerOff')
                end
            end
        end
    end
end

function createFlipButtons()
    local obj
    for k,v in pairs(lifeTokens) do
        obj = v.object
        if obj ~= nil then
            obj.clearButtons()
            obj.createButton({click_function = 'flipAliveToDead', function_owner = Global, position = {0,0.3,0}, rotation = {0,0,0}, width = 800, height = 800, color = {0,0,0,0}, tooltip = 'Flip Life Token'})
            obj.createButton({click_function = 'flipDeadToAliveCheck', function_owner = Global, position = {0,-0.1,0}, rotation = {180,0,0}, width = 800, height = 800, color = {0,0,0,0}, tooltip = 'Flip Life Token'})
        end
    end
end

function flipAliveToDead(clickedObject, playerColor)
    if playerColor == 'Black' and flipTimerExpired then
        flipTimerExpired = false
        Wait.time(flipCooldown, 1.5)
        local pos = clickedObject.getPosition()
        pos['y'] = 1.36
        clickedObject.setPositionSmooth(pos)
        clickedObject.setRotationSmooth({180,0,0})
        local voteToken = getObjectFromGUID(VOTE_TOKEN_BAG_GUID).takeObject({position = pos})
    end
end

function flipDeadToAliveCheck(clickedObject, playerColor)
    if playerColor == 'Black' and flipTimerExpired then
        flipTimerExpired = false
        Wait.time(flipCooldown, 1.5)
        flipDeadToAlive(clickedObject)
    end
end

function flipDeadToAlive(clickedObject)
    local pos = clickedObject.getPosition()
    local objectsFound = Physics.cast({origin = pos, direction = {0, 1, 0}, type = 2, max_distance = 3, debug = false})
    local voteTokenBag = getObjectFromGUID(VOTE_TOKEN_BAG_GUID)
    pos['y'] = 1.35
    clickedObject.setPositionSmooth(pos)
    clickedObject.setRotationSmooth({0,0,0})
    for i, hit in ipairs(objectsFound) do
        if hit.hit_object.getName() == 'Vote Token' then
            voteTokenBag.putObject(hit.hit_object)
        end
    end
end

function flipCooldown()
    flipTimerExpired = true
end

function resetGame()
    local mainTable = getObjectFromGUID(TABLE_GUID)
    local travelerBag = getObjectFromGUID(TRAVELER_BAG_GUID)
    local storageBag = getObjectFromGUID(STORAGE_BAG_GUID)
    local shroudBag = getObjectFromGUID(SHROUD_BAG_GUID)
    local allObjs = getAllObjects()
    local bags = {}
    for k,v in pairs(allObjs) do
        if string.match(v.getName(), ': Demons') then
            bags.Demon = v
        elseif string.match(v.getName(), ': Minions') then
            bags.Minion = v
        elseif string.match(v.getName(), ': Outsiders') then
            bags.Outsider = v
        elseif string.match(v.getName(), ': Townsfolk') then
            bags.Townsfolk = v
		elseif string.match(v.getName(), ': Travelers') then
			bags.Traveler = v
        elseif string.match(v.getName(), ': Reminder Tokens') then
            bags.Reminder = v
        end
    end

    local obj, objs, name, description
    history = {'[FFFFFF]Vote History:[-]'}
    mainTable.call('clearText')
    Global.setDecals({})
    started = false
    customSet = false
    chars = {}
    refreshUI()
    objs = storageBag.getObjects()
    for k,color in pairs(colors) do
        if not lifeTokens[color].object or lifeTokens[color].object.getDescription() == 'Traveler' then
            for k,v in pairs(objs) do
                if v.guid == LIFE_TOKEN_GUIDS[color] then
                    obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color]})
                    lifeTokens[color].object = obj
                    if storytellerMode then
                        obj.setLock(false)
                    else
                        obj.setLock(true)
                    end
                    obj.setScale({1.82,1,1.82})
                    obj.setRotationSmooth({0,0,0})
                    if storytellerMode then
                        obj.setPosition(radius(tableSize * 0.6 + 6, angle[color], 1.35))
                    else
                        obj.setPosition(radius(55, angle[color], 1.35))
                    end
                end
            end
        end
    end
    for k,v in pairs(COLORS) do
        obj = getObjectFromGUID(ZONE_GUIDS[v])
        if obj ~= nil then
            obj.setValue(v)
        end
    end

    for k,v in pairs(COLORS_EX) do
        obj = getObjectFromGUID(ZONE_GUIDS[v])
        if obj ~= nil then
            obj.setColorTint(FAKE_ZONE_RGB[v])
        end
    end

    for k,v in pairs(allObjs) do
        name = v.getName()
        description = v.getDescription()
        if name == 'Life Token' then
            if v.getDescription() == 'Traveler' then
                v.setLock(false)
                v.setRotation({0,0,0})
                    travelerBag.putObject(v)
            else
                if v.is_face_down then
                    flipDeadToAlive(v)
                end
            end
        elseif name == 'Shroud' then
            shroudBag.putObject(v)
        elseif description == 'Townsfolk' or description == 'Outsider' or description == 'Minion' or description == 'Demon' or description == 'Traveler' then
            v.setColorTint({1,1,1})
            v.setLock(false)
            bags[description].putObject(v)
        elseif description == 'Reminder Token' then
            v.setColorTint({1,1,1})
            bags.Reminder.putObject(v)
        end
    end

    local dealBag = getObjectFromGUID(DEAL_BAG_GUID)
    if dealBag ~= nil then
        local bagObjs = dealBag.getObjects()
        for k1, v1 in pairs(bagObjs) do
            takeObj = dealBag.takeObject()
            bags[takeObj.getDescription()].putObject(takeObj)
        end
    end

    local guillotine = getObjectFromGUID(GUILLOTINE_GUID)
    if guillotine ~= nil then
        guillotine.setPositionSmooth({26, 1, 111 + TABLE_OFFSET})
        guillotine.setRotationSmooth({0,0,0})
        guillotine.setLock(false)
    end
    grabObjectFromBag('Character Token Bag', storageBag, {0,1,125}, false)
    Wait.time(function () grabObjectFromBag('Character Tool', storageBag, {0,0,0}, true) end, 0.1)
    nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)
    nightHelper.call('reset')
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    clockControls.call('hideGrimoire')
    Wait.time(putVoteTokensInBag, 0.5)
    Wait.time(createFlipButtons, 0.5)
    Wait.time(function() clockControls.call('reloadGrimoire') end, 1)
end

function putVoteTokensInBag()
    local allObjs = getAllObjects()
    local voteTokenBag = getObjectFromGUID(VOTE_TOKEN_BAG_GUID)
    for k,v in pairs(allObjs) do
        if v.getName() == 'Vote Token' then
            voteTokenBag.putObject(v)
        end
    end
end

function grabObjectFromBag(name, bag, position, locked)
    local bagObjects = bag.getObjects()
    local obj
    local position = position
    position[3] = position[3] + TABLE_OFFSET
    for k,v in pairs(bagObjects) do
        if v.name == name then
            obj = bag.takeObject({index = v.index, position = position, rotation = {0,0,0}})
            obj.setLock(locked)
            return
        end
    end
end

------------------Object Calls
function getNumPlayers()
    local numPlayers = 0
    for k,v in pairs(COLORS_ALL) do
        if players[v] ~= nil then
            numPlayers = numPlayers + 1
        end
    end
    return numPlayers
end

function drawAllCharSheets()
    local allObjs = getAllObjects()
    for k,v in pairs(allObjs) do
        if string.match(v.getName(), ': Characters') then
            drawCharSheet(v)
        end
    end
end

function drawCharSheet(object)
    local found = {}
    object.clearButtons()
    object.setColorTint({0,0,0})

    local count = 0
    for k,v in pairs(customList) do
        count = count + 1
    end
    local z = -2

    if count < 30 then
        z_inc = 0.12
    else
        z_inc = 0.1
    end

    for k,v in pairs(TYPES) do
        found[v] = false
    end

    for k,v in pairs(customList) do
        found[CHARACTERS[v].Type] = true
    end

    for k,v in pairs(TYPES) do
        if found[v] then
            params = {click_function = 'nullFunc', label = COLORS_BBC_ROLE_TYPE[v] .. v, color = {1,1,1,1}, function_owner = self,
                position = {0,0.15,z}, rotation = {0,0,0}, width = 0, height = 0, font_size = 140, scale = {0.25,0.25,0.25}}
            object.createButton(params)
            z = z + z_inc * 1.5
        end

        for k1,v1 in pairs(customList) do
            if CHARACTERS[v1].Type == v then
                charLabel = v1
                params = {click_function = 'nullFunc', color = {1,1,1,1}, function_owner = self,
                    position = {0,0.15,z}, rotation = {0,0,0}, width = 0, height = 0, font_size = 120, scale = {0.25,0.25,0.25}}
                params.label = COLORS_BBC_ROLE_TYPE[CHARACTERS[v1].Type] .. charLabel .. '[FFFFFF] - ' .. CHARACTERS[v1].Description .. '[-]'
                object.createButton(params)
                z = z + z_inc
            end
        end
        z = z + z_inc
    end
end



------------------Events
function onPlayerChangeColor(color)
    if inTable(color, COLORS) and not inTable(color, colors) then
        Player[color].changeColor('Grey')
    else
        local obj = getObjectFromGUID(TEAM_TOOL_GUID)
        if obj ~= nil then
            Wait.time(function () obj.call('refreshUI') end, 0.1)
        else
            updatePlayers()
        end
    end
end

function onPlayerConnect(player)
    if options.jokersDefault then
        player.team = 'Jokers'
    end
    Wait.stop(timerID)
    timerID = Wait.time(function ()
        teamTool = getObjectFromGUID(TEAM_TOOL_GUID)
        if teamTool ~= nil then
            teamTool.reload()
        end
    end, 60)
    local characterTool = getObjectFromGUID(CHARACTER_TOOL_GUID)
    if characterTool ~= nil then
        characterTool.call('refreshMenu')
    end
end

function onPlayerDisconnect(player)
    local obj = getObjectFromGUID(TEAM_TOOL_GUID)
    if obj ~= nil then
        Wait.time(function () obj.call('refreshUI') end, 0.1)
    else
        updatePlayers()
    end
    local characterTool = getObjectFromGUID(CHARACTER_TOOL_GUID)
    if characterTool ~= nil then
        characterTool.call('refreshMenu')
    end
end

function onObjectDrop(playerColor, object)
    if playerColor ~= 'Black' or object.getGMNotes() ~= 'Character Token' or not autoTint then
        return
    end
    local pos
    local rad = tableSize * 0.4 + 6
    local posTable = {}
    Wait.time(function ()
        local objPos = object.getPosition()
        for k,v in pairs(colors) do
            pos = radius(rad, angle[v], 1.0)
            pos[3] = pos[3] + STORYTELLER_TABLE_DIST
            if math.abs(objPos[1] - pos[1]) < 1 and math.abs(objPos[3] - pos[3]) < 1 then
                object.setColorTint(COLORS_RGB[v])
                return
            end
        end
    end, 0.1)
end

------------------Chat commands
function onChat(message, player)
    local args = {} -- The arguments following a command
    local command, msg, len
    local receiverColor, receiverStrLen
    local colorFound = nil

    for v in string.gmatch(message, "%S+") do
        args[#args + 1] = v
    end

    if args[1] ~= nil then
        command = string.lower(args[1])
        len = string.len(command)
        if string.sub(command,1,1) == '.' then
            colorFound = findColor(string.sub(command, 2, -1))
        end
        if command == '.w' or command == 'w' then
            receiverColor = args[2]
            if not args[2] then
                return false
            end
            receiverStrLen = string.len(receiverColor)
            msg = string.sub(message, len + receiverStrLen + 3)

        elseif colorFound and string.len(command) > 3 then
            receiverColor = colorFound
            command = '.w'
            msg = string.sub(message, string.len(args[1]) + 2)
        else
            msg = string.sub(message, len + 2)
        end
    end

    if command == 'c' then
        player.print(HELP_MESSAGE)
        if player.admin then
            player.print(STORYTELLER_MESSAGE)
        end
        return false
    elseif command == 'h' then
        for k,v in pairs(history) do
            player.print(v)
        end
        return false
    elseif command == 'r' then
        updatePlayers()
        local char, charOut, formattedChar
        for k,v in pairs(players) do
            if v.steam_id == player.steam_id then
                char = chars[k]
                formattedChar = char
                if char == nil then
                    player.print('You do not have a character.')
                    return false
                else
                    charOut = char
                    player.print('Your character is ' .. formattedChar .. '!')
                    player.print(formattedChar .. ' - ' .. CHARACTERS[charOut].Description)
                    return false
                end
            end
        end
        player.print('You do not have a character.')
        return false
    elseif command == 'v' then
        player.print('Version ' .. VERSION)
        return false
    elseif command == 'n' then
        showNightLogs(player)
        return false
    elseif command == 'd' then
        showDayLogs(player)
        return false
    elseif command == 'l' then
        showAllLogs(player)
        return false
    elseif command == '.w' or command == 'w' then
        chatWhisper(player, capitalize(receiverColor), msg)
        return false
    elseif command == '.m' then
        if player.color == 'Black' or player.admin or player.steam_id == ADMIN_ID or DEBUG then
            chatMove(capitalize(args[2]), capitalize(args[3]), player)
            return false
        end
    elseif command == '.b' then
        if player.color == 'Black' or player.admin or player.steam_id == ADMIN_ID or DEBUG then
            chatRemove(capitalize(args[2]), player)
            return false
        end
    elseif command == '.s' then
        if player.color == 'Black' or player.admin or player.steam_id == ADMIN_ID or DEBUG then
            chatSwap(capitalize(args[2]), capitalize(args[3]), player)
            return false
        end
    elseif command == '.t' then
        if player.color == 'Black' or player.admin or player.steam_id == ADMIN_ID or DEBUG then
            chatToggleTraveler(capitalize(args[2]), player)
            return false
        end
    elseif command == '.u' then
        if player.color == 'Black' or player.admin or player.steam_id == ADMIN_ID or DEBUG then
            chatSetTeam(args[2], args[3], player)
            return false
        end
    elseif command == 'look' and DEBUG then
        chatLook(args[2], player)
        return false
    end

    if checkAdmin(player, message) == false then
        return false
    end

    for k,v in pairs(COLORS_EX) do
        if playersExIds[v] == player.steam_id then
            printToAll(COLORS_BBC[v] .. player.steam_name .. ':[-] ' .. message)
            return false
        end
    end
end

function capitalize(str)
    if not str then
        return
    end
    str = string.lower(str)
    return (str:gsub("^%l", string.upper))
end

function chatWhisper(player, color, message)
    updatePlayers()

    if not message or string.len(message) == 0 then
        return
    end

    local message = trim(message)
    local playerColor = getPlayer(player)
    local receiverColor = nil
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(color)) then
            receiverColor = v
            break
        end
    end

    if string.match('black', string.lower(color)) then
        receiverColor = 'Black'
    end

    if string.len(message) > 100 and playerColor ~= 'Black' then
        player.print('Character limit exceeded. Please shorten your message.', {1,0,0})
        return
    end

    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    local clockOn = clockControls.getVar('clockOn')
    local nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)

    if clockControls ~= nil and clockControls.getVar('allBlind') == true and not (playerColor == 'Black' or receiverColor == 'Black') then
        player.print('You cannot whisper during the night.', {1,0,0})
        return
    end

    if clockOn and not (playerColor == 'Black' or receiverColor == 'Black') then
        player.print('You cannot whisper during nominations.', {1,0,0})
        return
    end

    if not options.whispersOn and playerColor ~= 'Black' and receiverColor ~= 'Black' then
        player.print('Whispers are disabled. You can only communicate with the Storyteller.', {1,0,0})
        return
    end

    if not playerColor or not players[receiverColor] or playerColor == receiverColor then
        return
    end

    local sendMsg = COLORS_BBC[playerColor] .. playerColor .. ' [888888]-> ' .. COLORS_BBC[receiverColor] .. receiverColor .. ':[-] [FF7EFF]' .. message .. '[-]'
    player.print(sendMsg)
    players[receiverColor].print(sendMsg)
    local allBlind = clockControls.getVar('allBlind')
    if allBlind then
        local nightLog = nightHelper.getTable('nightLog')
        table.insert(nightLog[#nightLog], {sender = playerColor, receiver = receiverColor, message = message})
        nightHelper.setTable('nightLog', nightLog)
    else
        local dayLog = nightHelper.getTable('dayLog')
        table.insert(dayLog[#dayLog], {sender = playerColor, receiver = receiverColor, message = message})
        nightHelper.setTable('dayLog', dayLog)
    end

    if not (playerColor == 'Black' or receiverColor == 'Black') then
        Player['Black'].print(sendMsg)
    end
    if (playerColor ~= 'Black' and receiverColor ~= 'Black') then
        if not (whisperActive[playerColor][receiverColor]) then
            whisperActive[playerColor][receiverColor] = true
            Wait.time(|| setWhisperActiveFalse(playerColor, receiverColor), 5)
            local messageLength = string.len(message) + math.random(-5, 5)
            local messageLengthText = '[-]'
            if messageLength < 2 then messageLength = 2 end
            if options.whisperLengthOn then
                messageLengthText = '[888888]. [' .. messageLength .. ' characters][-]'
            end
            printToAll(COLORS_BBC[playerColor] .. playerColor .. ' [888888]has whispered to ' .. COLORS_BBC[receiverColor] .. receiverColor .. messageLengthText )
        end
    end
end

function trim(str)
   local idx = string.len(str)
   while string.sub(str, idx, idx) == ' ' do
       idx = idx - 1
       if idx == 0 then return '' end
   end
   local str = string.sub(str, 1, idx)
   local len = string.len(str)

   idx = 1
   while string.sub(str, idx, idx) == ' ' do
       idx = idx + 1
       if idx > len then return '' end
   end
   return string.sub(str, idx, len)
end

function setWhisperActiveFalse(playerColor, receiverColor)
    whisperActive[playerColor][receiverColor] = false
end

function chatMove(playerName, seatColor, player, swap)
    if playerName == nil or seatColor == nil then
        return
    end

    local playerFound = false
    local playerColor = nil
    local colorFound = false
    local playerList = Player.getPlayers()
    local numGreySeats = getNumGreySeats()

    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(seatColor)) then
            colorFound = v
            break
        end
    end
    if string.match('black', string.lower(seatColor)) then
        colorFound = 'Black'
    end

    if string.match('grey', string.lower(seatColor)) then
        colorFound = 'Grey'
    end
    if not colorFound then
        player.print('Error: Could not move player: invalid color.', {1,0,0})
        return
    end

    if not inTable(colorFound, colors) and not (colorFound == 'Black' or colorFound == 'Grey') then
        return
    end

    for k,v in pairs(playerList) do
        if string.match(string.lower(v.steam_name), string.lower(playerName)) then
            playerFound = v
        end
    end
    if not playerFound then
        player.print('Error: Could not move player: player not found.', {1,0,0})
        return
    end

    updatePlayers()
    if colorFound ~= 'Grey' and players[colorFound] ~= nil then
        player.print('Error: Could not move player: seat is already taken.', {1,0,0})
        return
    end

    for k,v in pairs(colors) do
        if players[v] ~= nil and players[v].steam_id == playerFound.steam_id then
            playerColor = v
        end
    end
    for k,v in pairs(playersExIds) do
        if playerFound.steam_id == v then
            unsitGreyColor(playerFound, k)
        end
    end
    playerFound.changeColor('Grey')
    if started and playerColor ~= nil and swap then
        rad = tableSize * 0.4 + 6
        swapObjects(playerColor, colorFound)

        chars[colorFound], chars[playerColor] = chars[playerColor], chars[colorFound]
        obj = getObjectFromGUID(NIGHT_HELPER_GUID)
        if obj ~= nil then
            obj.call('swapColors', {color1 = playerColor, color2 = colorFound})
        end
    end

    if colorFound == 'Grey' or colorFound == 'Black' or (inTable(colorFound, COLORS) and not Player[colorFound].seated) then
        playerFound.changeColor(colorFound)
    elseif inTable(colorFound, COLORS_EX) and players[colorFound] == nil then
        playerFound.changeColor('Grey')
        idx = getSeatIdx(colorFound)
        sitGreyColor(playerFound, colorFound)
    end
    player.print(playerFound.steam_name .. ' has been moved to ' .. colorFound .. '.')
    refreshUI()
end

function chatRemove(seatColor, player)
    if seatColor == nil then
        return
    end

    local colorFound = false
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(seatColor)) then
            colorFound = v
            break
        end
    end
    if string.match('black', string.lower(seatColor)) then
        colorFound = 'Black'
    end

    if not colorFound then
        player.print('Error: Invalid color.', {1,0,0})
        return
    end

    updatePlayers()
    if players[colorFound] ~= nil then
        player.print(players[colorFound].steam_name .. ' has been moved to Grey.')
        if inTable(colorFound, COLORS) or colorFound == 'Black' then
            players[colorFound].changeColor('Grey')
        else
            unsitGreyColor(players[colorFound], colorFound)
        end
    else
        player.print('Error: Could not remove player: seat is empty.', {1,0,0})
    end
end

function chatSwap(seatColor1, seatColor2, player)
    local color1, color2
    local player1id, player2id
    local obj

    if not seatColor1 or not seatColor2 then
        return
    end

    color1 = false
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(seatColor1)) then
            color1 = v
            break
        end
    end

    color2 = false
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(seatColor2)) then
            color2 = v
            break
        end
    end

    if not color1 then
        player.print('Error: The first color you entered is not a color.', {1,0,0})
        return
    end

    if not color2 then
        player.print('Error: The second color you entered is not a color.', {1,0,0})
        return
    end

    updatePlayers()
    if players[color1] == nil and players[color2] == nil then
        player.print('Error: No players seated in those colors.', {1,0,0})
        return
    end

    hideUI()
    swapChatLogs(color1, color2)
    swapLifeTokens(color1, color2)
    if players[color1] == nil then
        Wait.time(function () chatMove(players[color2].steam_name, color1, player, true) end, 0.1)
        return
    elseif players[color2] == nil then
        Wait.time(function () chatMove(players[color1].steam_name, color2, player, true) end, 0.1)
        return
    end

    player1id = players[color1].steam_id
    player2id = players[color2].steam_id

    if inTable(color1, COLORS) then
        players[color1].changeColor('Grey')
    else
        unsitGreyColor(players[color1], color1)
    end

    if inTable(color2, COLORS) then
        players[color2].changeColor('Grey')
    else
        unsitGreyColor(players[color2], color2)
    end

    if started then
        swapObjects(color1, color2)
        chars[color1],chars[color2] = chars[color2], chars[color1]

        obj = getObjectFromGUID(NIGHT_HELPER_GUID)
        if obj ~= nil then
            obj.call('swapColors', {color1 = color1, color2 = color2})
        end
    end

    for k,v in pairs(Player.getPlayers()) do
        if v.steam_id == player2id then
            player.print(v.steam_name .. ' has been moved to ' .. color1 .. '.')
            if inTable(color1, COLORS) then
                Wait.time(function() v.changeColor(color1) end, 0.1)
            elseif inTable(color1, COLORS_EX) then
                Wait.time(function() sitGreyColor(v, color1) end, 0,1)
            end
            break
        end
    end

    for k,v in pairs(Player.getPlayers()) do
        if v.steam_id == player1id then
            player.print(v.steam_name .. ' has been moved to ' .. color2 .. '.')
            if inTable(color2, COLORS) then
                Wait.time(function () v.changeColor(color2) end, 0.1)
            elseif inTable(color2, COLORS_EX) then
                Wait.time(function() sitGreyColor(v, color2) end, 0,1)
            end
            break
        end
    end
    Wait.time(refreshUI, 0.5)
end

function swapChatLogs(color1, color2)
    local nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)
    if nightHelper == nil then
        return
    end
    local dayLog = nightHelper.getTable('dayLog')
    local nightLog = nightHelper.getTable('nightLog')
    for k1,day in pairs(dayLog) do
        for k2, entry in pairs(day) do
            if entry.sender == color1 then
                entry.sender = color2
            elseif entry.sender == color2 then
                entry.sender = color1
            end
            if entry.receiver == color1 then
                entry.receiver = color2
            elseif entry.receiver == color2 then
                entry.receiver = color1
            end
        end
    end
    for k1,night in pairs(nightLog) do
        for k2, entry in pairs(night) do
            if entry.sender == color1 then
                entry.sender = color2
            elseif entry.sender == color2 then
                entry.sender = color1
            end
            if entry.receiver == color1 then
                entry.receiver = color2
            elseif entry.receiver == color2 then
                entry.receiver = color1
            end
        end
    end
    nightHelper.setTable('dayLog', dayLog)
    nightHelper.setTable('nightLog', nightLog)
end


function swapObjects(color1, color2)
    local rad, pos1, pos2
    local scriptZone, objs
    local margin = 1.5

    rad = tableSize * 0.4 + 6
    pos1 = radius(rad, angle[color1], 1.0)
    pos1[3] = pos1[3] + STORYTELLER_TABLE_DIST
    pos2 = radius(rad, angle[color2], 1.0)
    pos2[3] = pos2[3] + STORYTELLER_TABLE_DIST

    scriptZone = getObjectFromGUID(SCRIPTING_ZONE_GUID)
    if scriptZone ~= nil then
        objs = scriptZone.getObjects()
        for k,v in pairs(objs) do
            if math.abs(pos1[1] - v.getPosition()[1]) < margin and math.abs(pos1[3] - v.getPosition()[3]) < margin then
                v.setPositionSmooth(pos2)
                if v.getDescription() ~= '' then
                    v.setColorTint(COLORS_RGB[color2])
                end
            elseif math.abs(pos2[1] - v.getPosition()[1]) < margin and math.abs(pos2[3] - v.getPosition()[3]) < margin then
                v.setPositionSmooth(pos1)
                if v.getDescription() ~= '' then
                    v.setColorTint(COLORS_RGB[color1])
                end
            end
        end
    end
end

function swapLifeTokens(color1, color2)
    local lifeToken1 = lifeTokens[color1].object
    local lifeToken2 = lifeTokens[color2].object
    local voteToken1 = lifeTokens[color1].vote
    local voteToken2 = lifeTokens[color2].vote
    local type1, type2, obj, pos
    local storageBag = getObjectFromGUID(STORAGE_BAG_GUID)
    local travelerBag = getObjectFromGUID(TRAVELER_BAG_GUID)
    local objs = storageBag.getObjects()
    local rot1, rot2 = nil, nil
    if lifeToken1 == nil then
        type1 = 'None'
    elseif lifeToken1.getDescription() == 'Traveler' then
        type1 = 'Traveler'
        rot1 = lifeToken1.getRotation()
    else
        type1 = 'Normal'
        rot1 = lifeToken1.getRotation()
    end
    if lifeToken2 == nil then
        type2 = 'None'
    elseif lifeToken2.getDescription() == 'Traveler' then
        type2 = 'Traveler'
        rot2 = lifeToken2.getRotation()
    else
        type2 = 'Normal'
        rot2 = lifeToken2.getRotation()
    end
    if type1 == 'Normal' and type2 == 'Normal' then
        lifeToken1.setRotationSmooth(rot2)
        lifeToken2.setRotationSmooth(rot1)
    elseif type1 == 'None' and type2 == 'Normal' then
        storageBag.putObject(lifeToken2)
        for k,v in pairs(objs) do
            if v.guid == LIFE_TOKEN_GUIDS[color1] then
                obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color1]})
                lifeTokens[color1].object = obj
                obj.setPosition(lifeTokenPos[color1])
                obj.setRotation(rot2)
                break
            end
        end
    elseif type1 == 'Normal' and type2 == 'None' then
        storageBag.putObject(lifeToken1)
        for k,v in pairs(objs) do
            if v.guid == LIFE_TOKEN_GUIDS[color2] then
                obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color2]})
                lifeTokens[color2].object = obj
                obj.setPosition(lifeTokenPos[color2])
                obj.setRotation(rot1)
                break
            end
        end
    elseif type1 == 'None' and type2 == 'Traveler' then
        lifeToken2.setPositionSmooth(lifeTokenPos[color1])
    elseif type1 == 'Traveler' and type2 == 'None' then
        lifeToken1.setPositionSmooth(lifeTokenPos[color2])
    elseif type1 == 'Normal' and type2 == 'Traveler' then
        storageBag.putObject(lifeToken1)
        lifeToken2.setPositionSmooth(lifeTokenPos[color1])
        for k,v in pairs(objs) do
            if v.guid == LIFE_TOKEN_GUIDS[color2] then
                obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color2]})
                lifeTokens[color2].object = obj
                obj.setPosition(lifeTokenPos[color2])
                obj.setRotation(rot1)
                break
            end
        end
    elseif type1 == 'Traveler' and type2 == 'Normal' then
        storageBag.putObject(lifeToken2)
        lifeToken1.setPositionSmooth(lifeTokenPos[color2])
        for k,v in pairs(objs) do
            if v.guid == LIFE_TOKEN_GUIDS[color1] then
                obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color1]})
                lifeTokens[color1].object = obj
                obj.setPosition(lifeTokenPos[color1])
                obj.setRotation(rot2)
                break
            end
        end
    end

    if voteToken1 ~= nil and voteToken2 == nil then
        pos = lifeTokenPos[color2]
        pos[2] = 1.5
        voteToken1.setPositionSmooth(pos)
    elseif voteToken2 ~= nil and voteToken1 == nil then
        pos = lifeTokenPos[color1]
        pos[2] = 1.5
        voteToken2.setPositionSmooth(pos)
    end
    Wait.time(createFlipButtons, 1)
end

function chatSetTeam(playerName, team, player)
    local allPlayers = Player.getPlayers()
    local foundPlayer = nil
    local foundTeam = nil
    local teams = {'None', 'Jokers', 'Clubs', 'Spades', 'Diamonds', 'Hearts'}
    for k,v in pairs(allPlayers) do
        if string.match(string.lower(v.steam_name), string.lower(playerName)) then
            foundPlayer = v
        end
    end
    if not foundPlayer then
        player.print('Error: Player not found.', {1,0,0})
        return
    end
    for k,v in pairs(teams) do
        if string.match(string.lower(v), string.lower(team)) then
            foundTeam = v
        end
    end
    if not foundTeam then
        player.print('Error: Team not found.', {1,0,0})
        return
    end
    if foundTeam == 'None' or foundTeam == 'Jokers' then
        if options.jokersDefault then
            foundTeam = 'Jokers'
        else
            foundTeam = 'None'
        end
    end

    foundPlayer.team = foundTeam
end

function chatToggleTraveler(seatColor, player)
    local color = false
    local obj, pos
    local travelerBag = getObjectFromGUID(TRAVELER_BAG_GUID)
    local storageBag = getObjectFromGUID(STORAGE_BAG_GUID)
    local locked = true
    if storytellerMode then
        locked = false
    end
    if travelerBag == nil or storageBag == nil then
        return
    end
    if not seatColor then
        return
    end
    for k,v in pairs(COLORS_ALL) do
        if string.match(string.lower(v), string.lower(seatColor)) then
            color = v
            break
        end
    end
    if not color then
        player.print('Error: The first color you entered is not a color.', {1,0,0})
        return
    end
    obj = lifeTokens[color].object
    pos = lifeTokenPos[color]
    if obj == nil then
        obj = travelerBag.takeObject({position = pos, rotation = {0,0,0}})
        player.print(COLORS_BBC[color] .. color .. '[-] has been set as a traveler.')
    elseif obj.getGMNotes() == 'Traveler' then
        travelerBag.putObject(obj)
        obj = storageBag.takeObject({guid = LIFE_TOKEN_GUIDS[color], position = pos, rotation = {0,0,0}})
        player.print(COLORS_BBC[color] .. color .. '[-] has been set as a non-traveler.')
    else
        storageBag.putObject(obj)
        obj = travelerBag.takeObject({position = pos, rotation = {0,0,0}})
        player.print(COLORS_BBC[color] .. color .. '[-] has been set as a traveler.')
    end
    lifeTokens[color].object = obj
    obj.setLock(locked)
    Wait.time(createFlipButtons,1)
end

function chatLook(objectGUID, player)
    local obj = getObjectFromGUID(objectGUID)
    if obj ~= nil then
        local pos = obj.getPosition()
        player.lookAt({position = pos, pitch = 90, yaw = 180, distance = 5})
    end
end

function showNightLogs(player)
    local color = getPlayer(player)
    local msg
    if not color then
        return
    end
    local nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)
    if nightHelper == nil then
        return
    end
    local nightLog = nightHelper.getTable('nightLog')
    player.print('Night Log')
    for i1, night in ipairs(nightLog) do
        output = '[888888]-----Night ' .. i1 .. '-----[-]\n'
        for i2, entry in ipairs(night) do
            if (entry.sender == color or entry.receiver == color or color == 'Black') then
                msg = COLORS_BBC[entry.sender] .. entry.sender .. ' [888888]-> ' .. COLORS_BBC[entry.receiver] .. entry.receiver .. ':[-] [FF7EFF]' .. entry.message .. '[-]'
                output = output .. msg .. '\n'
            end
        end
        player.print(output)
    end
end

function showDayLogs(player)
    local color = getPlayer(player)
    local msg
    if not color then
        return
    end
    local nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)
    if nightHelper == nil then
        return
    end
    local dayLog = nightHelper.getTable('dayLog')
    player.print('Day Log')
    for i = 2, #dayLog do
        output = '[888888]-----Day ' .. i-1 .. '-----[-]\n'
        day = dayLog[i]
        for i2, entry in ipairs(day) do
            if (entry.sender == color or entry.receiver == color or color == 'Black') then
                msg = COLORS_BBC[entry.sender] .. entry.sender .. ' [888888]-> ' .. COLORS_BBC[entry.receiver] .. entry.receiver .. ':[-] [FF7EFF]' .. entry.message .. '[-]'
                output = output .. msg .. '\n'
            end
        end
        player.print(output)
    end
end

function showAllLogs(player)
    local color = getPlayer(player)
    if not color then
        return
    end
    local nightHelper = getObjectFromGUID(NIGHT_HELPER_GUID)
    local nightLog = nightHelper.getTable('nightLog')
    local dayLog = nightHelper.getTable('dayLog')
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if nightHelper == nil or clockControls == nil then
        return
    end
    local allBlind = clockControls.getVar('allBlind')
    local msg
    player.print('[89C381]Whisper Logs[-]')
    for i = 1, #nightLog do
        if i == #nightLog and not allBlind then
            break
        end
        output = '[888888]-----Night ' .. i .. '-----[-]\n'
        night = nightLog[i]
        for i2, entry in ipairs(night) do
            if (entry.sender == color or entry.receiver == color or color == 'Black') then
                msg = COLORS_BBC[entry.sender] .. entry.sender .. ' [888888]-> ' .. COLORS_BBC[entry.receiver] .. entry.receiver .. ':[-] [FF7EFF]' .. entry.message .. '[-]'
                output = output .. msg .. '\n'
            end
        end
        player.print(output)

        output = '[888888]-----Day ' .. i .. '-----[-]\n'
        if i+1 > #dayLog then
            break
        end
        day = dayLog[i+1]
        for i2, entry in ipairs(day) do
            if (entry.sender == color or entry.receiver == color or color == 'Black') then
                msg = COLORS_BBC[entry.sender] .. entry.sender .. ' [888888]-> ' .. COLORS_BBC[entry.receiver] .. entry.receiver .. ':[-] [FF7EFF]' .. entry.message .. '[-]'
                output = output .. msg .. '\n'
            end
        end
        player.print(output)
    end
end

------------------Functions called when game starts
function refreshUI()
    for k, v in pairs(COLORS) do
        UI.setAttribute('player' .. v, 'visibility', v)
        if chars[v] then
            UI.setValue('player' .. v, 'Your character is ' .. chars[v] .. '!')
        else
            UI.setValue('player' .. v, '')
        end
    end
end

function setCharText(color)
    if inTable(color, COLORS) then
        UI.setAttribute('player' .. color, 'visibility', color)
        UI.setValue('player' .. color, 'Your character is ' .. chars[color] .. '!')
    end
end

function removeCharText(color)
    if inTable(color, COLORS) then
        UI.setAttribute('player' .. color, 'visibility', color)
        UI.setValue('player' .. color, '')
    end
end

function hideUI()
    for k, v in pairs(COLORS) do
        UI.setAttribute('player' .. v, 'visibility', v)
        UI.setValue('player' .. v, '')
    end
end

function checkSeatedPlayers()
    local obj
    local allPlayers = Player.getPlayers()
    local storageBag = getObjectFromGUID(STORAGE_BAG_GUID)

    if DEBUG then
        return
    end
    updatePlayers()
    for k,v in pairs(COLORS) do
        if chars[v] == nil then
            obj = getObjectFromGUID(ZONE_GUIDS[v])
            if obj ~= nil then
                obj.setValue('Black')
            end
            obj = getObjectFromGUID(LIFE_TOKEN_GUIDS[v])
            if obj ~= nil then
                storageBag.putObject(obj)
            end
        end
    end
    for k,v in pairs(COLORS_EX) do
        if chars[v] == nil then
            obj = getObjectFromGUID(LIFE_TOKEN_GUIDS[v])
            if obj ~= nil then
                storageBag.putObject(obj)
            end
            obj = getObjectFromGUID(ZONE_GUIDS[v])
            if obj ~= nil then
                obj.setColorTint({0.30,0.30,0.30,0.25})
            end
        end
    end
end


------------------Voting functions
function vote(params)
    local voter = params.voter
    local handObj = getObjectFromGUID(VOTEHAND_GUIDS[voter])
    local index
    for k,color in pairs(colors) do
        if color == voter then
            index = k
            break
        end
    end
    if not voteLock[voter] then
        if voted[voter] then
            voted[voter] = false
            params.index = (index - 1) * 3 + 1
            params.color = {53/255,52/255,60/255}
            params.font_color = {1,1,1}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(params)
            if handObj then
                handObj.setScale(VOTEHAND_HIDE_SCALE)
                handObj.setPosition(radius(75, angle[voter], -5))
            end
        else
            voted[voter] = true
            params.index = (index - 1) * 3 + 1
            params.color = {236/255,229/255,44/255}
            params.font_color = {1,1,1}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(params)
            if handObj then
                handObj.setScale(VOTEHAND_SHOW_SCALE)
                handObj.setPositionSmooth(radius(45, angle[voter], 5))
            end
        end
    end
end

function setVoteLock(params)
    voteLock[params.color] = true
end

function nominate(params)
    local nominator = params.nominator
    local params = {}
    local nominatorIndex, nominatedIndex
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls == nil then
        return
    end
    if canNominate[nominator] == false then
        return
    end
    local rotating = clockControls.getVar('rotating')
    if rotating then
        return
    end
    for k,color in pairs(colors) do
        if color == nominator then
            nominatorIndex = k
            break
        end
    end

    if currentNominator == '' then
        currentNominator = nominator
        params.index = (nominatorIndex - 1) * 3 + 2
        params.color = {58/255, 150/255, 255/255}
        params.font_color = {1,1,1}
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(params)
        clockControls.call('pointHand', {handGUID = HOUR_HAND_GUID, color = nominator})
        UI.setAttribute('colorSelection','active','false')
        colorTable = false
    elseif currentNominator == nominator then
        currentNominator = ''
        params.index = (nominatorIndex - 1) * 3 + 2
        params.color = {53/255,52/255,60/255}
        params.font_color = {58/255, 150/255, 255/255}
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(params)
        clockControls.call('pointHand', {handGUID = HOUR_HAND_GUID, color = 'None'})
        if currentNominated ~= '' then
            for k,color in pairs(colors) do
                if color == currentNominated then
                    nominatedIndex = k
                    break
                end
            end
            params.index = (nominatedIndex - 1) * 3 + 0
            params.color = {53/255,52/255,60/255}
            params.font_color = {218/255, 25/255, 24/255}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(params)
            currentNominated = ''
            clockControls.call('pointHand', {handGUID = MINUTE_HAND_GUID, color = 'None'})
            clockControls.call('pointHand', {handGUID = SECOND_HAND_GUID, color = 'None'})
        end
        UI.setAttribute('colorSelection','active','false')
        colorTable = false
    else
        updatePlayers()
        if players[nominator] ~= nil then
            players[nominator].print(currentNominator .. ' is nominating a player. Please wait.', {1,0,0})
            return
        end
    end
end

function nominated(params)
    local player = params.player
    local target = params.target
    local index, nominatedIndex
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls == nil then
        return
    end
    local buttonParams = {}
    local rotating = clockControls.getVar('rotating')
    local nominateResult
    if rotating then
        return
    end
    for k,color in pairs(colors) do
        if color == target then
            index = k
        end
        if color == currentNominated then
            nominatedIndex = k
        end
    end


    if currentNominator ~= '' and currentNominator ~= player and player ~= 'Black' then
        players[player].print(currentNominator .. ' is nominating a player. Please wait.', {1,0,0})
        return
    end

    if currentNominator == '' and player ~= 'Black' then
        nominateResult = nominate({nominator = player})
    end

    if (player == currentNominator or player == 'Black') and canBeNominated[target] then
        if currentNominated == '' then
            currentNominated = target
            buttonParams.index = (index - 1) * 3 + 0
            buttonParams.color = {218/255, 25/255, 24/255}
            buttonParams.font_color = {1,1,1}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
            clockControls.call('pointHand', {handGUID = MINUTE_HAND_GUID, color = target})
            clockControls.call('pointHand', {handGUID = SECOND_HAND_GUID, color = target})
        elseif currentNominated == target then
            currentNominated = ''
            buttonParams.index = (index - 1) * 3 + 0
            buttonParams.color = {53/255,52/255,60/255}
            buttonParams.font_color = {218/255, 25/255, 24/255}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
            clockControls.call('pointHand', {handGUID = MINUTE_HAND_GUID, color = 'None'})
            clockControls.call('pointHand', {handGUID = SECOND_HAND_GUID, color = 'None'})
        else
            buttonParams.index = (nominatedIndex - 1) * 3 + 0
            buttonParams.color = {53/255,52/255,60/255}
            buttonParams.font_color = {218/255, 25/255, 24/255}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
            currentNominated = target
            buttonParams.index = (index - 1) * 3 + 0
            buttonParams.color = {218/255, 25/255, 24/255}
            buttonParams.font_color = {1,1,1}
            getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
            clockControls.call('pointHand', {handGUID = MINUTE_HAND_GUID, color = target})
            clockControls.call('pointHand', {handGUID = SECOND_HAND_GUID, color = target})
        end
    end
end

function resetCurrentNominations()
    local buttonParams = {}
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls == nil then
        return
    end
    local nominatorIndex, nominatedIndex

    if currentNominator ~= '' and canNominate[currentNominator] == true then
        for k,color in pairs(colors) do
            if color == currentNominator then
                index = k
                break
            end
        end

        buttonParams.index = (index - 1) * 3 + 2
        buttonParams.color = {53/255,52/255,60/255}
        buttonParams.font_color = {58/255, 150/255, 255/255}
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
    end
    if currentNominated ~= '' and canBeNominated[currentNominated] == true then
        for k,color in pairs(colors) do
            if color == currentNominated then
                index = k
                break
            end
        end
        buttonParams.index = (index - 1) * 3 + 0
        buttonParams.color = {53/255,52/255,60/255}
        buttonParams.font_color = {218/255, 25/255, 24/255}
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
    end
    currentNominator = ''
    currentNominated = ''
    clockControls.call('pointHand', {handGUID = HOUR_HAND_GUID, color = 'None'})
    clockControls.call('pointHand', {handGUID = MINUTE_HAND_GUID, color = 'None'})
    clockControls.call('pointHand', {handGUID = SECOND_HAND_GUID, color = 'None'})
end

function checkLiving()
    for k,v in pairs(COLORS_ALL) do
        if lifeTokens[v].object ~= nil then
            if lifeTokens[v].object.is_face_down == true then -- if life token is face down...
                living[v] = false
                if lifeTokens[v].vote ~= nil then -- ..then if a vote token is present
                    hasVote[v] = true
                else
                    hasVote[v] = false
                end
            else
                hasVote[v] = true
                living[v] = true
            end
        end
    end
end

function hideVoteButtons()
    local votePanel = getObjectFromGUID(VOTE_PANEL_GUID)
    if votePanel ~= nil then
        votePanel.clearButtons()
    end
    for k,v in pairs(COLORS_ALL) do
        voteButtonsOn[v] = false
    end
end

function showVoteButtons(params)
    local voteMode = params.voteMode
    local buttonParams = {}
    currentNominator = ''
    currentNominated = ''
    checkLiving()
    updatePlayers()
    for k,v in pairs(COLORS_ALL) do
        if lifeTokens[v].object ~= nil then
            voteButtonsOn[v] = true
            canBeNominated[v] = true
            voted[v] = false
            if living[v] or voteMode == 'exile' then
                canNominate[v] = true
            else
                canNominate[v] = false
            end
        else
            canNominate[v] = false
            voteButtonsOn[v] = false
        end
    end
    local votePanel = getObjectFromGUID(VOTE_PANEL_GUID)
    if votePanel ~= nil then
        votePanel.call('createButtons')
    end
end

function updateVoteResults(params)
    local voteMode = params.voteMode
    local numVotes = 0
    local nominationString = '[888888]Nomination: ' .. COLORS_BBC[currentNominator] .. currentNominator .. ' [888888]> ' .. COLORS_BBC[currentNominated] .. currentNominated .. '[-]\n'
    local voterString = '[888888]Voters:[-]'
    local actionStr

    if voteMode == 'execution' then
        actionStr = 'execute'
    else
        actionStr = 'exile'
    end

    for k,v in pairs(COLORS_ALL) do
        if voted[v] then
            numVotes = numVotes + 1
            voterString = voterString .. ' ' .. COLORS_BBC[v] .. v .. '[-]'
        end
    end
    if numVotes == 1 then
        broadcastToAll('Votes are in! '.. numVotes ..' player voted to '.. actionStr .. ' ' .. currentNominated ..'!', {1,0,0})
    else
        broadcastToAll('Votes are in! '.. numVotes ..' players voted to '.. actionStr .. ' ' .. currentNominated ..'!', {1,0,0})
    end
    moveGuillotine({player = currentNominated, numVotes = numVotes, voteMode = voteMode})
    if numVotes == 0 then
        voterString = '[888888]Voters: None[-]'
    end
    broadcastToAll(voterString, {1,1,1})
    history[#history] = history[#history] .. '\n' .. nominationString .. voterString .. '\n'
    notes = nominationString .. voterString
    setNotes(notes)

    checkLiving()
    updateNominations()
    resetVotes({voteMode = voteMode})
    removeVoteTokens({voteMode = voteMode})
end

function moveGuillotine(params)
    local player = params.player
    local numVotes = params.numVotes
    local voteMode = params.voteMode
    local guillotine = getObjectFromGUID(GUILLOTINE_GUID)
    local pos
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)

    if voteMode ~= 'execution' then
        return
    end

    if guillotine == nil then
        return
    end

    if numVotes >= math.ceil(numAlive/2) then
        if numVotes == currMostVotes then
            guillotine.setPositionSmooth({0,2,0 + TABLE_OFFSET})
            guillotine.setRotationSmooth({0,180,0})
            guillotine.setLock(true)
            clockControls.setVar('votesNeeded', numVotes + 1)
        elseif numVotes > currMostVotes then
            currMostVotes = numVotes
            pos = getObjectFromGUID(LIFE_BASE_GUIDS[player]).getPosition()
            pos[2] = 1.6
            guillotine.setPositionSmooth(pos)
            guillotine.setRotationSmooth({0, angle[player], 0})
            guillotine.setLock(false)
            clockControls.setVar('votesNeeded', numVotes + 1)
        end
    end
end

function updateNominations()
    canNominate[currentNominator] = false
    canBeNominated[currentNominated] = false
    local nominatorIndex, nominatedIndex
    local buttonParams = {}
    buttonParams.color = {0,0,0}
    buttonParams.font_color = {0,0,0}

    if currentNominator ~= '' then
        for k,color in pairs(colors) do
            if color == currentNominator then
                nominatorIndex = k
                break
            end
        end
        buttonParams.index = (nominatorIndex - 1) * 3 + 2
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
    end
    if currentNominated ~= '' then
        for k,color in pairs(colors) do
            if color == currentNominated then
                nominatedIndex = k
                break
            end
        end
        buttonParams.index = (nominatedIndex - 1) * 3 + 0
        getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
    end
    currentNominator = ''
    currentNominated = ''
    for k,v in pairs(COLORS_ALL) do
        if voted[v] and not living[v] then
            hasVote[v] = false
        end
    end
end

function resetVotes(params)
    local buttonParams = {}
    local handObj
    for k,v in pairs(colors) do
        if voteButtonsOn[v] then
            if hasVote[v] or params.voteMode == 'exile' then
                buttonParams.color = {53/255,52/255,60/255}
                buttonParams.font_color = {1,1,1}
                buttonParams.index = (k-1) * 3 + 1
                getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
                voteLock[v] = false
            else
                buttonParams.color = {0,0,0}
                buttonParams.font_color = {0,0,0}
                buttonParams.index = (k-1) * 3 + 1
                getObjectFromGUID(VOTE_PANEL_GUID).editButton(buttonParams)
                voteLock[v] = true
            end
        else
            voteLock[v] = false
        end
        voted[v] = false
    end
    hideVotehands()
end

function removeVoteTokens(params)
    local voteTokenBag = getObjectFromGUID(VOTE_TOKEN_BAG_GUID)
    for k,v in pairs(colors) do
        if not (hasVote[v] or params.voteMode == 'exile') then
            if lifeTokens[v].vote then
                voteTokenBag.putObject(lifeTokens[v].vote)
            end
        end
    end
end

function hideVotehands()
    local handObj
    for k,v in pairs(colors) do
        handObj = getObjectFromGUID(VOTEHAND_GUIDS[v])
        if handObj ~= nil then
            handObj.setScale(VOTEHAND_HIDE_SCALE)
            handObj.setPosition(radius(75, angle[v], -5))
        end
    end
end


------------------Grey UI
function showExtensionUI()
    local greySeats = {}
    for k,color in pairs(colors) do
        if COLORS_TYPE[color] == false then
            table.insert(greySeats, color)
        end
    end
    UI.setAttribute('placeDecalTB', 'active', 'false')
    UI.setAttribute('placeDecalBM', 'active', 'false')
    UI.setAttribute('placeDecalSV', 'active', 'false')
    UI.setAttribute('placeDecalCU', 'active', 'false')
    if options.decalsEnabled then
        UI.setAttribute('placeDecal'.. mode, 'active', 'true')
        UI.setAttribute('decalText', 'active', 'true')
    else
        UI.setAttribute('placeDecal'.. mode, 'active', 'false')
        UI.setAttribute('decalText', 'active', 'false')
    end
    for i = 5,20 do
        UI.setAttribute('whisperUI'..i, 'active', 'false')
        UI.setAttribute('blackWhisperUI'..i, 'active', 'false')
    end
    for i = 11,20 do
        UI.setAttribute('sitTable'..i, 'active', 'false')
    end
    if #greySeats == 0 then
        UI.setAttribute('placeDecal'.. mode, 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink')
        UI.setAttribute('decalText', 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink')
        UI.setAttribute('tableTextUI', 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink')
    else
        UI.setAttribute('placeDecal'.. mode, 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink|Grey')
        UI.setAttribute('decalText', 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink|Grey')
        UI.setAttribute('tableTextUI', 'visibility', 'White|Brown|Red|Orange|Yellow|Green|Teal|Blue|Purple|Pink|Grey')
        updateSitUI()
    end

    if options.tableText == false then
        UI.setAttribute('tableTextUI', 'active', 'false')
    end
    if options.whispersOn then
        UI.setAttribute('whisperUI'..tableSize + #removedColors, 'active', 'true')
        UI.setAttribute('whisperUI0', 'active', 'false')
    else
        UI.setAttribute('whisperUI'..tableSize + #removedColors, 'active', 'false')
        UI.setAttribute('whisperUI0', 'active', 'true')
    end
    UI.setAttribute('blackWhisperUI'..tableSize + #removedColors, 'active', 'true')
    setUIVisibility()
end

function updateSitUI()
    local greyColors = {}
    for k,color in pairs(colors) do
        if COLORS_TYPE[color] == false then
            table.insert(greyColors, color)
        end
    end
    local id = #greyColors + 10
    local delayFrames = 300
    for i,color in ipairs(greyColors) do
        if playersEx[color] == nil then
            UI.setAttributes('sit' .. id .. i, {text = 'Sit in ' .. color, colors = COLORS_UI[color], color = "#FFFFFF"})
        else
            UI.setAttributes('sit' .. id .. i, {text = 'Leave ' .. color, colors = COLORS_UI[color], color = "#FFFFFF"})
        end
    end
    UI.setAttribute('sitTable'.. id, 'active', 'true')
end

function disableTableText()
    local obj
    UI.setAttribute('tableTextUI', 'active', 'false')
    local mainTable = getObjectFromGUID(TABLE_GUID)
    mainTable.call('clearText')
end

function enableTableText()
    UI.setAttribute('tableTextUI', 'active', 'true')
end

function disableDecals()
    options.decalsEnabled = false
    UI.setAttribute('placeDecal' .. mode, 'active', 'false')
    UI.setAttribute('decalText', 'active', 'false')
    Global.setDecals({})
end

function enableDecals()
    options.decalsEnabled = true
    UI.setAttribute('placeDecal' .. mode, 'active', 'true')
    UI.setAttribute('decalText', 'active', 'true')
end

function disableWhispers()
    options.whispersOn = false
    UI.setAttribute('whisperUI'.. tableSize, 'active', 'false')
    UI.setAttribute('whisperUI'.. 0, 'active', 'true')
end

function enableWhispers()
    options.whispersOn = true
    UI.setAttribute('whisperUI'.. tableSize, 'active', 'true')
    UI.setAttribute('whisperUI'.. 0, 'active', 'false')
end

function disableWhisperLength()
    options.whisperLengthOn = false
end

function enableWhisperLength()
    options.whisperLengthOn = true
end

function toggleSafety()
    options.safetyOn = not options.safetyOn
end

function startSafetyCooldown()
    if safetyExpired == false then
        return
    end
    safetyExpired = false
    Wait.time(function() safetyExpired = true end, 2)
end

function setTableTextUI(player, value, id)
    local obj
    local mainTable = getObjectFromGUID(TABLE_GUID)
    updatePlayers()
    for k,v in pairs(colors) do
        if players[v] ~= nil and players[v].steam_id == player.steam_id then
            mainTable.call('setText', {color = v, text = value})
        end
    end
end

function formatTableText(text)
    local output = ''
    local lineLen = 0
    local LINE_WIDTH = 30

    for newL in text:gmatch("[^\r\n]+") do
        lineLen = 0
        for word in string.gmatch(newL, '%g+') do
            if lineLen + string.len(word) > LINE_WIDTH then
                while lineLen < LINE_WIDTH do
                    output = output .. ' '
                    lineLen = lineLen + 1
                end
                output = output .. '\n' .. word .. ' '
                lineLen = string.len(word) + 1
            else
                output = output .. word .. ' '
                lineLen = lineLen + string.len(word) + 1
            end
        end
        output = output .. '\n'
    end

    return output
end

function sitUI(player, value, id)
    local obj, zoneObj
    local gameSettings = getObjectFromGUID(GAME_SETTINGS_GUID)
    local mainTable = getObjectFromGUID(TABLE_GUID)
    local idx = tonumber(string.sub(id, 6, #id))
    local count = 0
    local color = getSeatColor(idx)

    updatePlayers()
    if playersEx[color] == nil then
        for k,v in pairs(playersEx) do
            if v ~= nil and v.steam_id == player.steam_id then
                player.print('You are already sitting in a seat.')
                return
            end
        end
        if options.seatLock then
            player.print('Extension seats are locked.')
            return
        end
        sitGreyColor(player, color)
    else
        if player.steam_id == playersEx[color].steam_id then
            unsitGreyColor(player, color)
        else
            player.print('Someone is already sitting in ' .. color .. '.')
        end
    end
    obj = getObjectFromGUID(TEAM_TOOL_GUID)
    if obj ~= nil then
        Wait.time(function () obj.call('refreshUI') end, 0.1)
    end
end

function sitGreyColor(player, color)
    player.print('You are now sitting in ' .. color .. '.')
    playersExIds[color] = player.steam_id
    playersEx[color] = player
    mainTable.call('setName', {color = color, name = player.steam_name})
    generateAvatar(color)
    printToAll(COLORS_BBC[color] .. player.steam_name .. ' is color ' .. color .. '.[-]')
    local idx = getSeatIdx(color)
    for i = 11,20 do
        UI.setAttributes('sit' .. i .. idx, {text =  'Leave ' .. color, color = '#FFFFFF'})
    end
end

function unsitGreyColor(player, color)
    player.print('You are no longer sitting in ' .. color .. '.')
    local idx = getSeatIdx(color)
    if idx then
        for i = 11,20 do
            UI.setAttributes('sit' .. i .. idx, {text =  'Sit in ' .. color, color = '#FFFFFF'})
        end
    end
    playersEx[color] = nil
    playersExIds[color] = nil
    mainTable.call('setName', {color = color, name = ''})
    deleteAvatar(color)
    if started then
        zoneObj = getObjectFromGUID(ZONE_GUIDS[color])
        if zoneObj ~= nil then
            zoneObj.setColorTint({0.30,0.30,0.30,0.25})
        end
    end
end

function getSeatColor(idx)
    local count = 0
    for k,v in pairs(colors) do
        if COLORS_TYPE[v] == false then
            count = count + 1
        end
        if count == idx then
            return v
        end
    end
    return nil
end

function getSeatIdx(color)
    local idx = 0
    for k,v in pairs(colors) do
        if COLORS_TYPE[v] == false then
            idx = idx + 1
        end
        if color == v then
            return idx
        end
    end
    return nil
end

function getNumGreySeats()
    local num = 0
    for k,v in pairs(colors) do
        if COLORS_TYPE[v] == false then
            num = num + 1
        end
    end
    return num
end

function generateAvatar(color)
    local objParam = {
        type = "Custom_Model",
        position = radius(84, angle[color], 6),
        rotation = {180, angle[color], 180},
        scale = {2.5, 2.5, 2.5},
        callback = "avatarCallback",
        sound = false
    }
    local obj
    if avatarGuids[color] then
        obj = getObjectFromGUID(avatarGuids[color])
        if obj ~= nil then
            obj.destruct()
        end
    end
    generateAvatarImageUrl(playersEx[color].steam_id)
    Wait.time(function()
        local avatar = spawnObject(objParam)
        avatar.setLock(true)
        avatar.setDescription(color .. " Avatar")
        avatar.interactable = false
        local customParam = {
            diffuse = avatarUrl,
            mesh = "http://cloud-3.steamusercontent.com/ugc/933813375177509684/900B7683E01C43C394C408BC38E034B305F1B3AA/",
            collider = "http://cloud-3.steamusercontent.com/ugc/487893695356616224/E3E39A827C062914E4185D8757A81D4D14892B8B/",
            type = 0,
            material = 3,
            cast_shadows = false
        }
        avatar.setCustomObject(customParam)
        light = getObjectFromGUID(AVATAR_LIGHT_GUIDS[color])
        if light ~= nil then
            light.call('powerOn')
        end
    end, 0.5)
end

function avatarCallback(objIn, paramsIn)
	local color = string.gsub(objIn.getDescription(), " Avatar", "")
	avatarGuids[color] = objIn.getGUID()
end

function generateAvatarImageUrl(steamId)
    local url = 'http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=E05421C6A86CAABADE2F700F492FFA4A&steamids=' .. steamId
    WebRequest.get(url, self, 'avatarUrlCB')
end

function avatarUrlCB(req)
    if req.is_done and not req.is_error then
        local response = JSON.decode(req.text)
        avatarUrl = response.response.players[1].avatarfull
    end
end

function deleteAvatar(color)
    if avatarGuids[color] then
        obj = getObjectFromGUID(avatarGuids[color])
        if obj ~= nil then
            obj.destruct()
        end
        avatarGuids[color] = nil
        light = getObjectFromGUID(AVATAR_LIGHT_GUIDS[color])
        if light ~= nil then
            light.call('powerOff')
        end
    end
end

function voteUI(player, value, id)
    local found = getPlayer(player)
    if not found then
        return
    end
    if lifeTokens[found].object == nil then
        return
    end
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    local clockOn = clockControls.getVar('clockOn')
    if not clockOn then
        return
    end
    local callParams = {}
    callParams.voter = found
    vote(callParams)
end

function nominatedDropdown(player, value, id)
    local found = getPlayer(player)
    if not found or found ~= currentNominator then
        return
    end
    if not inTable(found, COLORS) then
        found = 'Grey'
    end

	if (colorTable) then --colorSelection is visible
		UI.setAttribute('colorSelection','active','false')
		colorTable = false
	else --colorSelection is NOT visible
		UI.setAttribute('colorSelection','visibility',found)
		UI.setAttribute('colorSelection','active','true')
		colorTable = true
	end
end

function nominateUI(player, value, id)
    local found = getPlayer(player)
    if not found then
        return
    end
    if lifeTokens[found].object == nil then
        return
    end
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls == nil then
        return
    end
    local rotating = clockControls.getVar('rotating')
    if rotating then
        return
    end

    local callParams = {}
    callParams.nominator = found
    nominate(callParams)
    nominatedDropdown(player, value, id)
end

function nominatedUI(player, value, id)
    local found = getPlayer(player)
    local target = UI.getAttribute(id, 'text')
    if not found then
        return
    end
    if lifeTokens[target].object == nil then
        return
    end
    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    if clockControls == nil then
        return
    end
    local rotating = clockControls.getVar('rotating')
    if rotating then
        return
    end
    updatePlayers()
    if found ~= currentNominator then
        return
    end
    local callParams = {}
    callParams.player = found
    callParams.target = target
    nominated(callParams)
    UI.setAttribute('colorSelection','active','false')
    colorTable = false
end

function joinTeamUI(player, value, id)
    local found = getPlayer(player)
    if not found then
        return
    end
    local teamTool = getObjectFromGUID(TEAM_TOOL_GUID)
    if teamTool ~= nil then
        local params = {color = found, team = id}
        teamTool.call('joinTeamUI', params)
    end
end

function leaveTeamUI(player, value, id)
    local teamTool = getObjectFromGUID(TEAM_TOOL_GUID)
    local defaultTeam
    if options.jokersDefault then
        defaultTeam = 'Jokers'
    else
        defaultTeam = 'None'
    end

    if player.team ~= defaultTeam then
        player.team = defaultTeam
        if teamTool ~= nil then
            teamTool.call('refreshUI')
        end
    end
end

function whisperColorUI(player, value, id)
    local sender = getPlayer(player)
    if not sender then
        return
    end
	uiWhisperColor[sender] = value
end

function whisperInputUI(player, value, id)
    local sender = getPlayer(player)
    if not sender then
        return
    end
    uiWhisperInput[sender] = value
end

function sendWhisperUI(player, value, id)
    local sender = getPlayer(player)
    if not sender then
        return
    end
    chatWhisper(player, uiWhisperColor[sender], uiWhisperInput[sender])
    uiWhisperInput[sender] = ''
end

function decalUI(player, value, id)
    updatePlayers()
    local params = {}
    local found = getPlayer(player)
    if not found then
        return
    end
    local globalDecals = Global.getDecals()

    if globalDecals ~= nil then
        for i = #globalDecals,1,-1 do
            if math.abs(globalDecals[i].position[1] - radius(48, angle[found], 1.1)[1]) < 0.01 and math.abs(globalDecals[i].position[3] - radius(48, angle[found], 1.1)[3]) < 0.01 then
                table.remove(globalDecals,i)
            end
        end
        Global.setDecals({})
        Global.setDecals(globalDecals)
    end
    if value ~= "None" then
        params.name = value
        params.url = DECAL_URLS[value]
        params.position = radius(48, angle[found], 1.1)
        params.rotation = {90, angle[found] - 180, 0}
        params.scale = {8,8,8}
        Global.addDecal(params)
    end
end

function toggleUI(player, value, id)
    uiVisibility[player.color] = not uiVisibility[player.color]
    local colorSelectionVis = UI.getAttribute('colorSelection','visibility')
    if colorSelectionVis == player.color then
        UI.setAttribute('colorSelection', 'visibility', 'none')
    end
    setUIVisibility()
end

function setUIVisibility()
    local greySeats = {}
    for k,color in pairs(colors) do
        if COLORS_TYPE[color] == false then
            table.insert(greySeats, color)
        end
    end
    local visStr = ''
    local blackStr = 'None'

    if uiVisibility['Black'] then
        blackStr = 'Black'
    end

    for k,v in pairs(COLORS) do
        if uiVisibility[v] then
            visStr = visStr .. v .. '|'
        end
    end

    visStr = string.sub(visStr, 1, #visStr-1)
    if #greySeats > 0 then
        visStr = visStr .. '|Grey'
    end
    UI.setAttribute('placeDecalTB', 'visibility', visStr)
    UI.setAttribute('placeDecalBM', 'visibility', visStr)
    UI.setAttribute('placeDecalSV', 'visibility', visStr)
    UI.setAttribute('placeDecalCU', 'visibility', visStr)
    UI.setAttribute('decalText', 'visibility', visStr)
    UI.setAttribute('tableTextUI', 'visibility', visStr)
    UI.setAttribute('teamMenu', 'visibility', visStr)
    UI.setAttribute('leaveTeam', 'visibility', visStr)
    UI.setAttribute('leaveTeam', 'textColor', '#FFFFFF')
    if options.whispersOn then
        UI.setAttribute('whisperUI'..tableSize, 'visibility', visStr)
    else
        UI.setAttribute('whisperUI0', 'visibility', visStr)
    end
    UI.setAttribute('blackWhisperUI'..tableSize, 'visibility', blackStr)
    UI.setAttribute('teamMenuBlack', 'visibility', blackStr)
    UI.setAttribute('leaveTeamBlack', 'visibility', blackStr)
    UI.setAttribute('nomMenu', 'visibility', visStr)
    UI.setAttribute('aliveDisplay', 'visibility', visStr)
end
