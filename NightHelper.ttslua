--[[
Night Tool
Made by Sionar
--]]


------------------Constants
VERSION = '3.0.1'
COLORS = {'White', 'Brown', 'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple', 'Pink', 'Magenta', 'Lavender', 'Navy', 'Cyan', 'Mint', 'Lime', 'Peach', 'Coral', 'Maroon', 'Silver', 'Grey'}
COLORS_BBC = {White = '[FFFFFF]', Brown = '[703A16]', Red = '[DA1917]', Orange = '[F3631C]', Yellow = '[E6E42B]', Green = '[30B22A]', Teal = '[20B09A]', Blue = '[1E87FF]', Purple = '[9F1FEF]', Pink = '[F46FCD]', Magenta = '[FF007F]', Lavender = '[967BB6]', Navy = '[616BD4]', Cyan = '[49D5FD]', Mint = '[89C381]', Lime = '[B8F161]', Peach = '[F1D4A2]', Coral = '[E29A8A]', Maroon = '[800000]', Silver = '[BEBEBE]', Black = '[3F3F3F]', Grey = '[888888]', Prompt = '[93EB6A]'}
COLORS_RGB = {White = {1,1,1}, Brown = {113/255,59/255,23/255}, Red = {219/255,26/255,24/255}, Orange = {244/255,100/255,29/255}, Yellow = {231/255,229/255,44/255}, Green = {49/255,179/255,43/255}, Teal = {33/255,177/255,155/255}, Blue = {31/255,136/255,255/255}, Purple = {160/255,32/255,240/255}, Pink = {245/255,112/255,206/255}, Magenta = {255/255,0/255,127/255}, Lavender = {150/255,123/255,182/255}, Navy = {97/255,107/255,212/255}, Cyan = {73/255,213/255,253/255}, Mint = {137/255,195/255,129/255}, Lime = {184/255,241/255,97/255}, Peach = {241/255,212/255,162/255}, Coral = {226/255,154/255,138/255}, Maroon = {128/255,0,0}, Silver = {190/255,190/255,190/255}, Grey = {136/255, 136/255, 136/255}}

ROW_S = -7.3
ROW_W = 0.45
FONT_SIZE = 225
FONT_SIZE_LABEL = 360
BUTTON_SIZE = 270
BUTTON_Y = 0.1
BUTTON_COLOR = {0,0,0}
BUTTON_FONT_COLOR = {1,1,1}
COLUMN = {-6, -4, -3.35, -2.70, -2.05, -1.5, 4, 6.3}
ROW = {}
for i = 1,40 do
    ROW[i] = ROW_S + i * ROW_W
end
LIVING_LAB_Z = -7.75
NIGHT_LAB_Z = -7.75
PREVIEW_LAB_Z = 3.15
PREVIEW_MSG_Z = 4.3
ADDCHAR_LAB_X = -4
ADDCHAR_LAB_Z = 3.15
ADD_BUT_X = -0.8
INPUTS_X = {-5.5, -2.3}
INPUTS_LAB_Z = 4.1
INPUT_BUT_Z = 5
BOTTOM_BUT_X = {-8, -6.5, -5, -3.5}
BOTTOM_BUT_Z = 8

#include GUIDs.ttslua


------------------Variables
living = {}
order = {}
orderRef = nil
minionColors = {}
demonColor = ''
unblind = {}
blindAuto = true
checkPrompts = true
message = ''
charAdd = ''
colorAdd = ''
currentMsg = ''
sendMsg = ''
evilMsg = ''
p1, p2, p3, p4 = '', '', '', ''
dayNum = 0
dayLog = {{}}
nightLog = {{}}
currentChar = ''
demonBluffs = {nil, nil, nil}


------------------Load/save
function onLoad(saveString)
    TABLE_OFFSET = Global.getVar('TABLE_OFFSET')
    moveBoard()
    if not (saveString == '') then
        local save = JSON.decode(saveString)
        living = save['l']
        order = save['o']
        orderRef = save['r']
        demonColor = save['d']
        unblind = save['u']
        checkPrompts = save['c']
        blindAuto = save['b']
        dayNum = save['day']
        nightLog = save['nl']
        dayLog = save['dl']
    end
    refreshUI()
    self.setDescription('v ' .. VERSION .. '\nMade by Sionar')
end

function onSave()
    local save = {}
    save['l'] = living
    save['o'] = order
    save['r'] = orderRef
    save['d'] = demonColor
    save['u'] = unblind
    save['c'] = checkPrompts
    save['b'] = blindAuto
    save['day'] = dayNum
    save['nl'] = nightLog
    save['dl'] = dayLog

    local saveString = JSON.encode(save)
    return saveString
end


------------------Functions
function moveBoard()
    local modName = Global.getVar('MOD_NAME')
    local TABLE_OFFSET, STORYTELLER_TABLE_DIST
    if modName == 'Blood on the Clocktower' then
        TABLE_OFFSET = Global.getVar('TABLE_OFFSET')
        STORYTELLER_TABLE_DIST = Global.getVar('STORYTELLER_TABLE_DIST')
        self.setPositionSmooth({0,1.2,TABLE_OFFSET + STORYTELLER_TABLE_DIST + 27})
        self.setLock(true)
    end
end

function importCall()
    import(_, 'Black')
end

function import(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    local chars = Global.getTable('chars')
    local numChars = 0
    local lunaticColor = false
    local tempDemonColor
    local demonName
    local found = false

    for k,v in pairs(chars) do
        numChars = numChars + 1
    end
    if numChars == 0 then
        return
    end
    local entry = {}
    living = {}
    minionColors = {}
    for k,v in pairs(chars) do
        playerChar = v
        entry = {color = k, char = playerChar, used = false, alive = true, sober = true, sane = true}
        table.insert(living, entry)
        if CHARACTERS[playerChar].Type == 'Minion' then
            found = false
            for k1,v1 in pairs(minionColors) do
                if v1 == entry.color then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(minionColors, entry.color)
            end
        elseif CHARACTERS[playerChar].Type == 'Demon' then
            demonColor = entry.color
            demonName = entry.char
        end
    end
    for k,v in pairs(living) do
        if v.char == 'Lunatic' then
            lunaticColor = v.color
            tempDemonColor = demonColor
            demonColor = lunaticColor
            v.char = demonName
            for k1,v1 in pairs(living) do
                if v1.color == tempDemonColor then
                    v1.char = 'Lunatic'
                    break
                end
            end
            break
        end
    end

    local minionStr = 'Minions:'
    for i = 1, #minionColors do
        minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
    end
    if demonColor == '' then
        evilMsg = 'Demon: , ' .. minionStr
    else
        evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
    end
    setNightOrder('first')
    setMsg()
end

function setNightOrder(night)
    order = {}
    local players = Global.call('updatePlayers')
    local mode = Global.getVar('mode')
    if blindAuto then
        for k,v in pairs(unblind) do
            if players[v] ~= nil then
                players[v].blindfolded = true
            end
        end
        unblind = {}
    end
    if night == 'first' then
        table.insert(order, {char = 'Evil Info', color = 'White'})
        table.insert(order, {char = 'Demon Info', color = demonColor})
        orderRef = FIRST[mode]
    else
        orderRef = OTHER[mode]
    end
    for k1,v1 in pairs(orderRef) do
        for k2,v2 in pairs(living) do
            if v2.char == v1 and v2.char ~= 'Ravenkeeper' and v2.char ~= 'Sage' and v2.char ~= 'Barber' and v2.char ~= 'Cartographer' then
                if v2.alive and (CHARACTERS[v2.char].Ability == false or (CHARACTERS[v2.char].Ability == true and v2.used == false)) then
                    if v2.char == 'Lunatic' and night == 'first' then
                        table.insert(order, 1, {char = 'Lunatic InfoA', color = v2.color})
                        table.insert(order, 2, {char = 'Lunatic InfoB', color = v2.color})
                        table.insert(order, 3, {char = 'Lunatic InfoC', color = demonColor})
                        table.insert(order, v2)
                    elseif v2.char == 'Lunatic' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Lunatic InfoD', color = demonColor})
                    elseif v2.char == 'Godfather' and night == 'first' then
                        table.insert(order, {char = 'Godfather Info', color = v2.color})
                    elseif v2.char == 'Rakshasa' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Rakshasa Kill', color = v2.color})
                    elseif v2.char == 'Ysbaddaden' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Ysbaddaden Kill', color = v2.color})
                    elseif v2.char == 'Jabberwocky' and night == 'other' then
                        table.insert(order, v2)
                        table.insert(order, {char = 'Jabberwocky Kill', color = v2.color})
                    elseif v2.char == 'Chieftain' and night == 'first' then
                        table.insert(order, {char = 'Chieftain Info', color = v2.color})
                    elseif v2.char == 'Trapper' and night == 'first' then
                        table.insert(order, {char = 'Trapper Info', color = v2.color})
                    elseif v2.char == 'Ambusher' and night == 'first' then
                        table.insert(order, {char = 'Ambusher Info', color = v2.color})
                    elseif v2.char == 'Bogman' and night == 'first' then
                        table.insert(order, {char = 'Bogman Info', color = v2.color})
                    elseif v2.char == 'Inquisitor' and night == 'other' then
                        table.insert(order, {char = 'Inquisitor Info', color = v2.color})
                    elseif CHARACTERS[v2.char].Response == true then
                        table.insert(order, v2)
                        table.insert(order, {char = v2.char .. '2', color = v2.color})
                    else
                        table.insert(order, v2)
                    end
                end
            end
        end
    end

    for k,v in pairs(living) do
        if not v.sane then
            table.insert(order, {char = 'Madness', color = v.color})
        end
    end

    table.insert(order, {char = 'Next Night', color = 'White'})
    sortOrder()
    currentChar = order[1].char
    setMsg()
    modifyPrompts(currentChar)
end

function sortOrder()
    local sortedOrder = {}
    for k,v in pairs(orderRef) do
        for k1,v1 in pairs(order) do
            if v == v1.char then
                table.insert(sortedOrder, v1)
            end
        end
    end
    order = sortedOrder
    currentChar = order[1].char
end

function setMsg()
    if #order == 0 then
        currentMsg = ''
        sendMsg = ''
        refreshUI()
        return
    end
    local char = order[1].char
    if currentChar ~= char then
        currentChar = char
        modifyPrompts(char)
    end

    if currentChar == 'Evil Info' then
        currentMsg = evilMsg
    elseif currentChar == 'Demon Info' then
        setDemonBluffs()
        modifyPrompts('Demon Info')
        return
    elseif currentChar == 'Next Night' then
        currentMsg = ''
    else
        currentMsg = CHARACTERS[currentChar].Prompt
    end
    sendMsg = currentMsg
    refreshUI()
end

function setDemonBluffs()
    local zoneObjs = getObjectFromGUID(SCRIPTING_ZONE_GUID).getObjects()
    local pos, gmNotes
    local formattedBluffs = {'P1', 'P2', 'P3'}
    local textColor
    demonBluffs = {nil,nil,nil}
    for k,v in pairs(zoneObjs) do
        pos = v.getPosition()
        gmNotes = v.getGMNotes()
        if gmNotes == 'Character Token' and math.abs(pos[1] - 4) < 1 and math.abs(pos[3] - 129) < 1 then
            demonBluffs[1] = v.getName()
        elseif gmNotes == 'Character Token' and math.abs(pos[1] - 0) < 1 and math.abs(pos[3] - 129) < 1 then
            demonBluffs[2] = v.getName()
        elseif gmNotes == 'Character Token' and math.abs(pos[1] + 4) < 1 and math.abs(pos[3] - 129) < 1 then
            demonBluffs[3] = v.getName()
        end
    end
    for i,v in pairs(demonBluffs) do
        if v ~= nil then
            if CHARACTERS[v].Type == 'Townsfolk' then
                textColor = COLORS_BBC['Blue']
            elseif CHARACTERS[v].Type == 'Outsider' then
                textColor = COLORS_BBC['Teal']
            elseif CHARACTERS[v].Type == 'Minion' then
                textColor = COLORS_BBC['Orange']
            elseif CHARACTERS[v].Type == 'Demon' then
                textColor = COLORS_BBC['Red']
            elseif CHARACTERS[v].Type == 'Traveler' then
                textColor = COLORS_BBC['Green']
            end
            formattedBluffs[i] = textColor .. v .. '[-]'
        end
    end
    currentMsg = CHARACTERS['Demon Info'].Prompt
    p1 = formattedBluffs[1]
    p2 = formattedBluffs[2]
    p3 = formattedBluffs[3]
    editMsg()
end

function getKey(table, value)
    for k,v in pairs(table) do
        if value == v then
            return k
        end
    end
    return nil
end

function inTable(table, value)
    for k,v in pairs(table) do
        if v == value then
            return true
        end
    end
    return false
end

function used(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    local entry = living[i]
    local char = living[i].char
    living[i].used = not living[i].used
    if CHARACTERS[char].Ability == true and living[i].used == true then
        for k,v in pairs(order) do
            if living[i].char == v.char then
                table.remove(order, k)
            end
        end
        if CHARACTERS[char].Response == true then
            for k,v in pairs(order) do
                if living[i].char .. '2' == v.char then
                    table.remove(order, k)
                end
            end
        end
    end
    setMsg()
end

for k = 1,30 do
    _G['used' .. k] = function(obj, col)
        used(obj, col, k)
    end
end

function alive(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    local entry = {color = living[i].color, char = living[i].char}
    living[i].alive = not living[i].alive

    if not living[i].alive and (entry.char == 'Ravenkeeper' or entry.char == 'Sage' or entry.char == 'Barber' or entry.char == 'Cartographer') then
        if orderRef ~= nil then
            orderIndex = getKey(orderRef, entry.char)
            if orderIndex == nil then
                refreshUI()
                return
            end
            for i = 1, #order do
                if orderIndex < getKey(orderRef, order[i].char) then
                    orderPos = i
                    break
                end
            end
            if orderPos == nil then
                orderPos = #order + 1
            end
            if entry.char == 'Barber' or entry.char == 'Cartographer' then
                entry.color = demonColor
            end
            table.insert(order, orderPos, {color = entry.color, char = entry.char})
            if entry.char == 'Ravenkeeper' then
                table.insert(order, orderPos + 1, {color = entry.color, char = 'Ravenkeeper2'})
            end
        end
    elseif not living[i].alive then
        removeCharFromOrder(living[i].char, living[i].color)
    elseif living[i].alive then
        addCharToOrder(living[i].char, living[i].color)
    end
    placeShroud(i)
    setMsg()
end

for k = 1,30 do
    _G['alive' .. k] = function(obj, col)
        alive(obj, col, k)
    end
end

function placeShroud(i)
    local started = Global.getVar('started')
    if not started then
        return
    end
    local tableSize = Global.getVar('tableSize')
    local angle = Global.getTable('angle')
    local color = living[i].color
    local rad = tableSize * 0.4 + 6
    local pos = radius(rad, angle[color], 1.25)
    pos['z'] = pos['z'] + 129 + TABLE_OFFSET
    local found = nil
    local shroudBag = getObjectFromGUID(SHROUD_BAG_GUID)
    local zoneObjs = getObjectFromGUID(SCRIPTING_ZONE_GUID).getObjects()
    local vPos
    if shroudBag == nil then
        return
    end

    for k,v in pairs(zoneObjs) do
        if v.getName() == 'Shroud' then
            vPos = v.getPosition()
            if math.abs(vPos['x'] - pos['x']) < 1 and math.abs(vPos['z'] - pos['z']) < 1 then
                found = v
                break
            end
        end
    end

    if living[i].alive then
        if found then
            shroudBag.putObject(found)
        end
    else
        if not found then
            shroudBag.takeObject({position = pos, rotation = {0,0,0}})
        end
    end
end

function radius(rad, angle, height)
    return {x = rad*math.sin(angle*math.pi/180), y = height, z = rad*math.cos(angle*math.pi/180)}
end

function sober(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    living[i].sober = not living[i].sober
    setMsg()
end

for k = 1,30 do
    _G['sober' .. k] = function(obj, col)
        sober(obj, col, k)
    end
end

function sane(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    local entry = living[i]
    local char = living[i].char
    local found = false

    living[i].sane = not living[i].sane

    if living[i].sane then
        for k,v in pairs(order) do
            if v.char == 'Madness' and v.color == entry.color then
                table.remove(order,k)
                table.insert(order, k, {char = 'Sane', color = entry.color})
            end
        end
    else
        for k,v in pairs(order) do
            if v.char == 'Madness' and v.color == entry.color then
                found = true
                break
            end
        end
        if not found then
            table.insert(order, {char = 'Madness', color = entry.color})
            sortOrder()
        end
    end
    currentChar = order[1].char
    setMsg()
    modifyPrompts(currentChar)
end

for k = 1,30 do
    _G['sane' .. k] = function(obj, col)
        sane(obj, col, k)
    end
end


function remove(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    local entry = living[i]
    local num = 0
    for k,v in pairs(living) do
        if v.color == entry.color then
            num = num + 1
        end
    end
    table.remove(living, i)

    if num <= 1 then
        local chars = Global.getTable('chars')
        chars[entry.color] = nil
        Global.setTable('chars', chars)
        Global.call('removeCharText', entry.color)

        for k,v in pairs(minionColors) do
            if v == entry.color then
                table.remove(minionColors,k)
                local minionStr = 'Minions:'
                for i = 1, #minionColors do
                    minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
                end
                if demonColor == '' then
                    evilMsg = 'Demon: , ' .. minionStr
                else
                    evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
                end
            end
        end
    end
    removeCharFromOrder(entry.char, entry.color)
    setMsg()
end

for k = 1,30 do
    _G['remove' .. k] = function(obj, col)
        remove(obj, col, k)
    end
end

function send(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    local clockControls = getObjectFromGUID(CLOCK_CONTROLS_GUID)
    local steam_name = Player[playerColor].steam_name
    local sendColor, msg
    local players = Global.call('updatePlayers')
    local allBlind = clockControls.getVar('allBlind')
    if clockControls ~= nil then
        clockControls.call('hideGrimoire')
    end

    if order[1].char == 'Evil Info' then
        if demonColor ~= '' then
            msg = COLORS_BBC['Black'] .. 'Black' .. ' [888888]-> ' .. COLORS_BBC[demonColor] .. demonColor .. '[-]: ' .. evilMsg
            table.insert(nightLog[#nightLog], {sender = 'Black', receiver = demonColor, message = evilMsg})
            if players[demonColor] ~= nil then
                players[demonColor].print(msg)
            end
            printToColor(msg, 'Black', {1,1,1})
        end
        for i = 1, #minionColors do
            msg = COLORS_BBC['Black'] .. 'Black' .. ' [888888]-> ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]: ' .. evilMsg
            table.insert(nightLog[#nightLog], {sender = 'Black', receiver = minionColors[i], message = evilMsg})
            if players[minionColors[i]] ~= nil then
                players[minionColors[i]].print(msg)
            end
            printToColor(msg, 'Black', {1,1,1})
        end
    elseif order[1].char == 'Next Night' then
        if blindAuto then
            for k,v in pairs(unblind) do
                if players[v] ~= nil then
                    players[v].blindfolded = true
                end
            end
            unblind = {}
        end
        setNightOrder('other')
        setMsg()
        dayNum = dayNum + 1
        local history = Global.getTable('history')
        table.insert(history, '\n[808080]----------Day ' .. dayNum .. '----------[-]')
        Global.setTable('history', history)
        table.insert(dayLog, {})
        table.insert(nightLog, {})
        return
    elseif order[1].char == 'Lil Monsta' then
        for i = 1, #minionColors do
            msg = COLORS_BBC['Black'] .. 'Black' .. ' [888888]-> ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]:[-] ' .. COLORS_BBC['Prompt'] .. sendMsg .. '[-]'
            table.insert(nightLog[#nightLog], {sender = 'Black', receiver = minionColors[i], message = sendMsg})
            if players[minionColors[i]] ~= nil then
                players[minionColors[i]].print(msg)
            end
            printToColor(msg, 'Black', {1,1,1})
        end
        if blindAuto then
            for k,v in pairs(unblind) do
                if players[v] ~= nil then
                    players[v].blindfolded = true
                end
            end
            unblind = {}
            for i = 1, #minionColors do
                table.insert(unblind, minionColors[i])
                if players[minionColors[i]] ~= nil then
                    players[minionColors[i]].blindfolded = false
                end
            end
        end
    else
        if checkPrompts then
            if string.match(sendMsg, 'P1') or string.match(sendMsg, 'P2') or string.match(sendMsg, 'P3') or string.match(sendMsg, 'P4') then
                Player[playerColor].print('Error: Fill in the prompts before sending the message.', {1,0,0})
                setMsg()
                return
            end
        end
        sendColor = order[1].color
        msg = COLORS_BBC['Black'] .. 'Black [888888]-> ' .. COLORS_BBC[sendColor] .. sendColor .. '[-]:[-] ' .. COLORS_BBC['Prompt'] .. sendMsg .. '[-]'
        if players[sendColor] ~= nil then
            players[sendColor].print(msg)
        end
        printToColor(msg, 'Black', {1,1,1})
        table.insert(nightLog[#nightLog], {sender = 'Black', receiver = sendColor, message = sendMsg})
        if blindAuto and order[1].char ~= 'Lunatic InfoA' then
            for k,v in pairs(unblind) do
                if players[v] ~= nil then
                    players[v].blindfolded = true
                end
            end
            unblind = {}
            table.insert(unblind, order[1].color)
            if players[unblind[1]] ~= nil then
                players[unblind[1]].blindfolded = false
            end
        end
    end
    table.remove(order, 1)
    p1, p2, p3, p4 = '', '', '', ''
    setMsg()
end

function skip(clickedObject, playerColor, i)
    if playerColor ~= 'Black' then
        return
    end

    table.remove(order, i)
    setMsg()
end

for k = 1,30 do
    _G['skip' .. k] = function(obj, col)
        skip(obj, col, k)
    end
end

function nullFunc() end

function firstNight(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    setNightOrder('first')
end

function otherNight(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    setNightOrder('other')
end

function charInput(obj, color, input, stillEditing)
    if not stillEditing then
        local found = false
        local formattedInput = input
        for k,v in pairs(CHARACTERS) do
            if string.lower(k) == string.lower(formattedInput) and formattedInput ~= '' then
                charAdd = k
                found = true
                break
            end
        end
        if found then
            refreshUI()
            return 1
        end
        for k,v in pairs(CHARACTERS) do
            if string.match(string.lower(k), string.lower(formattedInput)) and formattedInput ~= '' then
                charAdd = k
                break
            end
        end
        refreshUI()
        return 1
    end
end

function colorDropSelect(player, value, id)
    colorAdd = value
end

function modifyPrompts(character)
    local uiTab = self.UI.getXmlTable()
    local char_list
    local mode = Global.getVar('mode')
    local colors = Global.getTable('colors')
    local customList = Global.getTable('customList')
    if mode == 'TB' then
        char_list = TB_LIST
    elseif mode == 'BM' then
        char_list = BM_LIST
    elseif mode == 'SV' then
        char_list = SV_LIST
    elseif mode == 'CU' then
        char_list = customList
    end

    local dropdown, id
    for i = 1,4 do
        promptKey = 'P' .. i
        dropdown = uiTab[i+1].children[1]
        dropdown.children = {}
        if PROMPTS[character] and PROMPTS[character][promptKey] ~= nil then
            uiTab[i+1].attributes.active = true
            insertOption(dropdown.children, "Prompt ".. i)
            if PROMPTS[character][promptKey].type == 'Demon Info' then
                for k,char in pairs(char_list) do
                    if CHARACTERS[char].Type == 'Townsfolk' or CHARACTERS[char].Type == 'Outsider' then
                        if char == demonBluffs[i] then
                            insertOption(dropdown.children, char, true)
                        else
                            insertOption(dropdown.children, char, false)
                        end
                    end
                end
            elseif PROMPTS[character][promptKey].type == 'Character' then
                if PROMPTS[character][promptKey].quality == 'All' then
                    for k,char in pairs(char_list) do
                        insertOption(dropdown.children, char)
                    end
                elseif PROMPTS[character][promptKey].quality == 'Good' then
                    for k,char in pairs(char_list) do
                        if CHARACTERS[char].Type == 'Townsfolk' or CHARACTERS[char].Type == 'Outsider' then
                            insertOption(dropdown.children, char)
                        end
                    end
                elseif PROMPTS[character][promptKey].quality == 'Evil' then
                    for k,char in pairs(char_list) do
                        if CHARACTERS[char].Type == 'Minion' or CHARACTERS[char].Type == 'Demon' then
                            insertOption(dropdown.children, char)
                        end
                    end
                else
                    for k,char in pairs(char_list) do
                        if CHARACTERS[char].Type == PROMPTS[character][promptKey].quality then
                            insertOption(dropdown.children, char)
                        end
                    end
                end
            elseif PROMPTS[character][promptKey].type == 'Color' then
                for k,color in pairs(colors) do
                    insertOption(dropdown.children, color)
                end
            elseif PROMPTS[character][promptKey].type == 'Number' then
                for j = PROMPTS[character][promptKey].min, PROMPTS[character][promptKey].max do
                    insertOption(dropdown.children, j)
                end
            elseif PROMPTS[character][promptKey].type == 'State' then
                if PROMPTS[character][promptKey].quality == 'Alignment' then
                    insertOption(dropdown.children, "Good")
                    insertOption(dropdown.children, "Evil")
                elseif PROMPTS[character][promptKey].quality == 'Is' then
                    insertOption(dropdown.children, "is")
                    insertOption(dropdown.children, "is not")
                elseif PROMPTS[character][promptKey].quality == 'Are' then
                    insertOption(dropdown.children, "are")
                    insertOption(dropdown.children, "are not")
                elseif PROMPTS[character][promptKey].quality == 'Has' then
                    insertOption(dropdown.children, "has")
                    insertOption(dropdown.children, "has not")
                elseif PROMPTS[character][promptKey].quality == 'Have' then
                    insertOption(dropdown.children, "have")
                    insertOption(dropdown.children, "do not have")
                elseif PROMPTS[character][promptKey].quality == 'Do' then
                    insertOption(dropdown.children, "do")
                    insertOption(dropdown.children, "do not")
                end
            end
        else
            uiTab[i+1].attributes.active = false
        end
    end
    self.UI.setXmlTable(uiTab)
end

function insertOption(tab, value, selected)
    local attributes = nil
    if selected then
        attributes = {selected = true}
    end
    local option = {
        tag = "Option",
        value = value,
        attributes = attributes,
        children = nil
    }
    table.insert(tab, option)
end

function promptSelect(player, value, id)
    local num = string.sub(id, -1, -1)
    local str = value
    local textColor
    if string.match(str, "Prompt") then
        str = "P" .. string.sub(str, -1, -1)
    elseif PROMPTS[currentChar]['P'..num].type == 'Color' then
        str = COLORS_BBC[value] .. value .. '[-]'
    elseif PROMPTS[currentChar]['P'..num].type == 'Character' or PROMPTS[currentChar]['P'..num].type == 'Demon Info' then
        if CHARACTERS[value].Type == 'Townsfolk' then
            textColor = COLORS_BBC['Blue']
        elseif CHARACTERS[value].Type == 'Outsider' then
            textColor = COLORS_BBC['Teal']
        elseif CHARACTERS[value].Type == 'Minion' then
            textColor = COLORS_BBC['Orange']
        elseif CHARACTERS[value].Type == 'Demon' then
            textColor = COLORS_BBC['Red']
        elseif CHARACTERS[value].Type == 'Traveler' then
            textColor = COLORS_BBC['Green']
        elseif CHARACTERS[value].Type == 'Status' then
            textColor = COLORS_BBC['Purple']
        end
        str = textColor .. value .. '[-]'
    elseif PROMPTS[currentChar]['P'..num].type == 'State' then
        if str == 'Evil' or string.match(str, 'not') then
            textColor = COLORS_BBC['Red']
        else
            textColor = COLORS_BBC['Blue']
        end
        str = textColor .. value .. '[-]'
    end
    _G['p'..num] = str
    editMsg()
end

function editMsg()
    local msg = currentMsg
    msg = string.gsub(msg, 'P1', p1)
    msg = string.gsub(msg, 'P2', p2)
    msg = string.gsub(msg, 'P3', p3)
    msg = string.gsub(msg, 'P4', p4)
    sendMsg = msg
    refreshUI()
end

function addChar(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end
    local pos, colorIndex
    if colorAdd == '' or charAdd == '' then
        broadcastToColor('ERROR: The character or color field is empty.', playerColor, {1,0,0})
        return
    end
    local char = charAdd
    if #living == 0 then
        pos = 1
    else
        colorIndex = getKey(COLORS, colorAdd)
        for i = 1, #living do
            if colorIndex < getKey(COLORS, living[i].color) then
                pos = i
                break
            end
        end
        if pos == nil then
            pos = #living + 1
        end
    end
    if char == 'Lil Monsta' then
        pos = #living + 1
        colorAdd = 'Grey'
    end
    table.insert(living, pos, {color = colorAdd, char = char, used = false, alive = true, sober = true, sane = true})
    if CHARACTERS[char].Type == 'Demon' or CHARACTERS[char].Type == 'Minion' then
        if CHARACTERS[char].Type == 'Demon' then
            demonColor = colorAdd
        elseif CHARACTERS[char].Type == 'Minion' then
            found = false
            for k,v in pairs(minionColors) do
                if v == colorAdd then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(minionColors, colorAdd)
            end
        end
        local minionStr = 'Minions:'
        for i = 1, #minionColors do
            minionStr = minionStr .. ' ' .. COLORS_BBC[minionColors[i]] .. minionColors[i] .. '[-]'
        end
        if demonColor == '' then
            evilMsg = 'Demon: , ' .. minionStr
        else
            evilMsg = 'Demon: ' .. COLORS_BBC[demonColor] .. demonColor .. '[-], ' .. minionStr
        end
    end
    if char == 'Ravenkeeper' or char == 'Sage' or char == 'Barber' then
        refreshUI()
        return
    end
    addCharToOrder(char, colorAdd)
end

function addCharToOrder(char, color)
    local orderPos, orderIndex
    local found

    local chars = Global.getTable('chars')
    if chars[color] == nil then
        chars[color] = char
        Global.setTable('chars', chars)
        Global.call('setCharText', color)
    end

    if orderRef ~= nil then
        orderIndex = getKey(orderRef, char)
        if orderIndex == nil then
            refreshUI()
            return
        end
        for i = 1, #order do
            if orderIndex < getKey(orderRef, order[i].char) then
                orderPos = i
                break
            end
        end
        if orderPos == nil then
            orderPos = #order + 1
        end
        table.insert(order, orderPos, {char = char, color = color})
        if char == 'Lunatic' then
            table.insert(order, 1, {char = 'Lunatic InfoA', color = color})
            table.insert(order, 2, {char = 'Lunatic InfoB', color = color})
            table.insert(order, 3, {char = 'Lunatic InfoC', color = demonColor})
            table.insert(order, orderPos+4, {char = 'Lunatic InfoD', color = demonColor})
            setMsg()
        elseif char == 'Godfather' then
            table.insert(order, 1, {char = 'Godfather Info', color = color})
        elseif CHARACTERS[char].Response == true then
            table.insert(order, orderPos+1, {char = char .. '2', color = color})
        end
    end
    setMsg()
end

function removeCharFromOrder(char, color)
    if order ~= nil then
        for i = #order,1,-1 do
            if string.match(order[i].char, char) and order[i].color == color then
                table.remove(order, i)
            end
        end
        if char == 'Lunatic' then
            for i = #order,1,-1 do
                if string.match(order[i].char, 'Lunatic') then
                    table.remove(order, i)
                end
            end
        end
    end
end

function toggleCheck(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    checkPrompts = not checkPrompts
    refreshUI()
    if checkPrompts then
        broadcastToColor('Prompt checking enabled.', playerColor, {1,1,1})
    else
        broadcastToColor('Prompt checking disabled.', playerColor, {1,1,1})
    end
end

function toggleBlind(clickedObject, playerColor)
    if playerColor ~= 'Black' then
        return
    end

    blindAuto = not blindAuto
    refreshUI()
    if blindAuto then
        broadcastToColor('Automatic blindfolding enabled.', playerColor, {1,1,1})
    else
        broadcastToColor('Automatic blindfolding disabled.', playerColor, {1,1,1})
    end
end

function format(string)
    local lineMax = 45
    local result
    local lineLen = 0
    local output = ''
    for word in string.gmatch(string, '%g+') do
        if lineLen + string.len(word) + 1 > lineMax then
            output = output .. '\n' .. word
            lineLen = string.len(word)
        else
            if lineLen == 0 then
                output = output .. word
                lineLen = lineLen + string.len(word)
            else
                output = output .. ' ' .. word
                lineLen = lineLen + 1 + string.len(word)
            end
        end
    end
    return output
end

function swapColors(params)
    local color1 = params.color1
    local color2 = params.color2
    local chars = Global.getTable('chars')
    local index, tempUsed
    local entry
    local color1Living = nil
    local color2Living = nil

    for i = 1, #living do
        if living[i].color == color1 then
            color1Living = i
        elseif living[i].color == color2 then
            color2Living = i
        end
    end

    if not color1Living and not color2Living then
        return
    end

    if color1Living and color2Living then
        living[color1Living], living[color2Living] = living[color2Living], living[color1Living]
        living[color1Living].color, living[color2Living].color = living[color2Living].color, living[color1Living].color
    elseif color1Living and not color2Living then
        entry = living[color1Living]
        table.remove(living, color1Living)
        index = findLivingIndex(color2)
        table.insert(living, index, entry)
        living[index].color = color2
    elseif not color1Living and color2Living then
        entry = living[color2Living]
        table.remove(living, color2Living)
        index = findLivingIndex(color1)
        table.insert(living, index, entry)
        living[index].color = color1
    end

    setNightOrder('other')
end

function findLivingIndex(color)
    local colorIdx = colorIndex(color)
    local index
    for i = 1, #living do
        index = colorIndex(living[i].color)
        if colorIdx < index then
            return i
        end
    end
    return #living + 1
end

function colorIndex(color)
    local index = 1
    for k,v in pairs(COLORS) do
        if v == color then
            return index
        end
        index = index + 1
    end
    return nil
end

function reset()
    living = {}
    order = {}
    orderRef = {}
    demonColor = ''
    blind = {}
    dayNum = 0
    nightLog = {{}}
    dayLog = {{}}
    refreshUI()
end

------------------UI
function refreshUI()
    self.clearInputs()
    self.clearButtons()
    local buttonParam = {}
    local inputParam = {}
    local char

    buttonParam = {click_function = 'nullFunc', label = 'Characters', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {-4.5,BUTTON_Y,LIVING_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Night Order', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {4.5,BUTTON_Y,NIGHT_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    for i = 1, #living do
        buttonParam = {click_function = 'nullFunc', function_owner = self, label = living[i].char, color = {0,0,0,1}, font_color = COLORS_RGB[living[i].color], position = {COLUMN[1],BUTTON_Y,ROW[i]}, width = 0, height = 0, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        char = living[i].char
        if CHARACTERS[char].Ability == true then
            buttonParam = {click_function = 'used'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[2],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
            if living[i].used == false then
                buttonParam.label = 'Has\nAbility'
                buttonParam.font_color = stringColorToRGB('Blue')
            else
                buttonParam.label = 'No\nAbility'
                buttonParam.font_color = stringColorToRGB('Red')
            end
            self.createButton(buttonParam)
        end

        buttonParam = {click_function = 'alive'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[3],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].alive then
            buttonParam.label = 'Alive'
            buttonParam.font_color = stringColorToRGB('Blue')
        else
            buttonParam.label = 'Dead'
            buttonParam.font_color = stringColorToRGB('Red')
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'sober'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[4],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].sober then
            buttonParam.label = 'Sober/\nHealthy'
            buttonParam.font_color = stringColorToRGB('Blue')
        else
            buttonParam.label = 'Drunk/\nPoisoned'
            buttonParam.font_color = stringColorToRGB('Red')
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'sane'..i, function_owner = self, color = {0,0,0,1}, position = {COLUMN[5],BUTTON_Y,ROW[i]}, width = 3200, height = 2300, font_size = 1200, scale = {0.1,0.1,0.1}}
        if living[i].sane then
            buttonParam.label = 'Sane'
            buttonParam.font_color = stringColorToRGB('Blue')
        else
            buttonParam.label = 'Mad'
            buttonParam.font_color = stringColorToRGB('Red')
        end
        self.createButton(buttonParam)

        buttonParam = {click_function = 'remove'..i, function_owner = self, label = 'âœ•', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[6],BUTTON_Y,ROW[i]}, width = 2300, height = 2300, scale = {0.1,0.1,0.1}, font_size = FONT_SIZE * 10, tooltip = 'Remove from list'}
        self.createButton(buttonParam)
    end

    if #order > 0 then
        buttonParam = {click_function = 'send', function_owner = self, label = order[1].char, color = {0,0,0,1}, font_color = COLORS_RGB[order[1].color], position = {COLUMN[7],BUTTON_Y,ROW[1]}, width = 1350, height = 230, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        buttonParam = {click_function = 'skip1', function_owner = self, label = 'Skip', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[8],BUTTON_Y,ROW[1]}, width = 675, height = 230, font_size = FONT_SIZE,}
        self.createButton(buttonParam)
    end

    for i = 2, #order do
        buttonParam = {click_function = 'nullFunc', function_owner = self, label = order[i].char, color = {0,0,0,1}, font_color = COLORS_RGB[order[i].color], position = {COLUMN[7],BUTTON_Y,ROW[i]}, width = 0, height = 0, font_size = FONT_SIZE,}
        self.createButton(buttonParam)

        buttonParam = {click_function = 'skip'..i, function_owner = self, label = 'Skip', color = {0,0,0,1}, font_color = stringColorToRGB('Red'), position = {COLUMN[8],BUTTON_Y,ROW[i]}, width = 675, height = 200, font_size = FONT_SIZE,}
        self.createButton(buttonParam)
    end

    buttonParam = {click_function = 'nullFunc', label = 'Preview', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {COLUMN[7],BUTTON_Y,PREVIEW_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = format(sendMsg), color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {COLUMN[7],BUTTON_Y,PREVIEW_MSG_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Add Character', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {ADDCHAR_LAB_X,BUTTON_Y,ADDCHAR_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE_LABEL,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'nullFunc', label = 'Character', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[1],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)


    buttonParam = {click_function = 'nullFunc', label = 'Color', color = {1,1,1,1}, font_color = stringColorToRGB('White'), function_owner = self,
        position = {INPUTS_X[2],BUTTON_Y,INPUTS_LAB_Z}, rotation = {0,0,0}, width = 0, height = 0, font_size = FONT_SIZE,}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'addChar', label = '+', color = {0,0,0}, font_color = {1,1,1}, function_owner = self, position = {ADD_BUT_X,BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 333, height = 333, font_size = FONT_SIZE, tooltip = 'Add character to game'}
    self.createButton(buttonParam)

    inputParam = {input_function = 'charInput', color = {1,1,1}, function_owner = self, font_color = {0,0,0}, function_owner = self,
        position = {INPUTS_X[1],BUTTON_Y,INPUT_BUT_Z}, rotation = {0,0,0}, width = 1800, height = 260, font_size = FONT_SIZE, value = charAdd, alignment = 3, validation = 1, tab = 2}
    self.createInput(inputParam)

    buttonParam = {click_function = 'toggleCheck', label = 'Check\nPrompts\n[0000FF]ON[-]', color = {0,0,0}, font_color = {1,1,1}, function_owner = self, position = {BOTTOM_BUT_X[1],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 700, height = 600, font_size = 120, tooltip = 'Check if prompts have been filled in'}
    if not checkPrompts then
        buttonParam.label = 'Check\nPrompts\n[FF0000]OFF[-]'
    end
    self.createButton(buttonParam)

    buttonParam = {click_function = 'toggleBlind', label = 'Auto\nBlindfold\n[0000FF]ON[-]', color = {0,0,0}, font_color = {1,1,1}, function_owner = self, position = {BOTTOM_BUT_X[2],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 700, height = 600, font_size = 120, tooltip = 'Toggle Auto Blindfold'}
    if not blindAuto then
        buttonParam.label = 'Auto\nBlindfold\n[FF0000]OFF[-]'
    end
    self.createButton(buttonParam)

    buttonParam = {click_function = 'firstNight', label = 'First\nNight', color = {0,0,0}, font_color = {1,1,1}, function_owner = self, position = {BOTTOM_BUT_X[3],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 700, height = 600, font_size = 120, tooltip = 'Set night order\nfor first night'}
    self.createButton(buttonParam)

    buttonParam = {click_function = 'otherNight', label = 'Other\nNights', color = {0,0,0}, font_color = {1,1,1}, function_owner = self, position = {BOTTOM_BUT_X[4],BUTTON_Y,BOTTOM_BUT_Z}, rotation = {0,0,0}, width = 700, height = 600, font_size = 120, tooltip = 'Set night order\nfor other nights'}
    self.createButton(buttonParam)
end
